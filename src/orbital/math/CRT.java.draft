// draft
class CRT {
    /**
     * Simulatenously solve the independent congruences
     * <center>x &equiv; x<sub>i</sub> (mod m<sub>i</sub>) for i=1,...,n</center>
     * per Chinese Remainder Theorem.
     * The Chinese Remainder Theorem guarantees a unique solution
     * (modulo m<sub>1</sub>*...*m<sub>n</sub>).
     * <p>
     *    Remark: the isomorphisms involved are useful for computing with the Chinese Remainder Algorithm. They are
     *    <ul>
     *      <li>x &#8614; <big>(</big>x (mod m<sub>1</sub>),...,x (mod m<sub>n</sub>)<big>)</big></li>
     *      <li>&sum;<sub>i=1,...,n</sub> x<sub>i</sub><big>(</big>(&prod;<sub>j&ne;i</sub> m<sub>j</sub>)<sup>-1</sup> (mod m<sub>i</sub>)<big>)</big>&prod;<sub>j&ne;i</sub> m<sub>j</sub> &#8612; (x<sub>1</sub>,...,x<sub>n</sub>)</li>
     *    </ul>
     * </p>
     * <p>
     * The incremental algorithm is
     * <pre>
     * x := x<sub>1</sub>
     * M := 1
     * <span class="keyword">for</span> i := 2 <span class="keyword">to</span> n <span class="keyword">do</span>
     *     M := M*m<sub>i-1</sub>
     *     x := x + <big>(</big>(x<sub>i</sub> - x)*(M<sup>-1</sup> mod m<sub>i</sub>) mod m<sub>i</sub><big>)</big> * M
     * <span class="keyword">end for</span>
     * <span class="keyword">return</span> x
     * </pre>
     * </p>
     * @param x the array of congruence values x<sub>1</sub>,...,x<sub>n</sub>.
     * @param m the moduli m<sub>1</sub>,...,m<sub>n</sub>.
     * @return the unique solution x (modulo m<sub>1</sub>*...*m<sub>n</sub>).
     * @internal implements Chinese Remainder Algorithm which is a direct consequence of the
     *  Chinese Remainder Theorem.
     */
    public static final Arithmetic chineseRemainder(Arithmetic x[], Arithmetic m[]) {
	if (x.length != m.length)
	    throw new IllegalArgumentException("must give the same number of congruence values and modulos");
	Arithmetic m = 1;
	Arithmetic x = x[0];
	for (int i = 1; i < m.length; i++) {
	    m = m*m[i-1];
	    final Arithmetic c = m^-1 (mod m[i]);		// the inverse modulo m[i] of m
	    final Arithmetic s = (x[i] - x)*c mod m[i];
	    x = x + s*m;
	}
	return x;
    }
}
