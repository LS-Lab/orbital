<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-gb">
<meta name="author" content="Andre Platzer">
<meta name="copyright" content="© 2002 André Platzer">
<meta name="classification" content="Science/Mathematics/Category/Basics">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Category theory</title>
<link rel="stylesheet" href="../../../../stylist.css" type="text/css" title="layout">
</head>

<body>

<h2>Contents</h2>
<ul>
  <li><a href="#categoriesAndFunctors">Categories and Functors</a>
  <li><a href="#universalElements">Universal Elements</a></li>
  <li><a href="#products">Product and Coproduct</a></li>
</ul>
<h2 id="categoriesAndFunctors">Categories and Functors</h2>
<p>&quot;general abstract nonsense&quot;, &quot;functors leave complexes 
complex&quot;</p>
<dl class="def">
  <dt id="category">category</dt>
  <dd>A category <span class="category">C</span> consists of a family Ob <span class="category">C</span> 
    of <i>objects</i>, and for each A,B∈Ob <span class="category">C</span> a 
    set Mor<span class="category"><sub>C</sub></span>(A,B) of <i>morphisms</i> 
    between A and B such that
    <table>
      <tr>
        <th>(r)</th>
        <td>∀A∈Ob <span class="category">C</span> ∃id<sub>A</sub>∈Mor<sub><span class="category">C</span></sub>(A,A)</td>
        <td>&quot;reflexive, identity&quot;</td>
      </tr>
      <tr>
        <th>(t)</th>
        <td>∀A,B,C∈Ob <span class="category">C</span> ∃∘:Mor<span class="category"><sub>C</sub></span>(B,C)×Mor<span class="category"><sub>C</sub></span>(A,B)→Mor<span class="category"><sub>C</sub></span>(A,C) 
          with</td>
        <td>&quot;transitive, composition&quot;</td>
      </tr>
      <tr>
        <th rowspan="2">(n)</th>
        <td>∀A,B∈Ob <span class="category">C</span> ∀g∈Mor<span class="category"><sub>C</sub></span>(A,B) 
          g∘id<sub>A</sub> = g</td>
        <td rowspan="2">&quot;neutral&quot;</td>
      </tr>
      <tr>
        <td>∀A,B∈Ob <span class="category">C</span> ∀f∈Mor<span class="category"><sub>C</sub></span>(B,A) 
          id<sub>A</sub>∘f = f</td>
      </tr>
      <tr>
        <th>(a)</th>
        <td>∀A,B,C,D∈Ob <span class="category">C</span> ∀f∈Mor<span class="category"><sub>C</sub></span>(A,B)∀g∈Mor<span class="category"><sub>C</sub></span>(B,C)∀h∈Mor<span class="category"><sub>C</sub></span>(C,D) 
          (h∘g)∘f = h∘(g∘f)</td>
        <td>&quot;associative&quot;</td>
      </tr>
    </table>
    We usually assume that Mor<span class="category"><sub>C</sub></span>(A,B) 
    ∩ Mor<span class="category"><sub>C</sub></span>(C,D) = ∅ unless A=C ∧ 
    B=D.<br>
    Write: f:A→B for f∈Mor<span class="category"><sub>C</sub></span>(A,B)
    <p><span style="float: left; font-size: 200%">☡</span> Beware: Unlike Mor<span class="category"><sub>C</sub></span>(A,B), 
    Ob <span class="category">C</span> does not need to be a set of objects, but 
    only a class of objects. Nevertheless we formally write ∈,⊆ etc.</p>
  </dd>
  <dt id="functor">covariant<br>
    functor</dt>
  <dd>A covariant functor F:<span class="category">C</span>→<span class="category">D</span> 
    between two categories <span class="category">C</span> and <span class="category">D</span> 
    consists of a map F:Ob <span class="category">C</span>→Ob <span class="category">D</span> 
    and for each A,B∈Ob <span class="category">C</span> a map F:Mor<span class="category"><sub>C</sub></span>(A,B)→Mor<span class="category"><sub>D</sub></span>(F(A),F(B)) 
    that satisfies the following conditions
    <table>
      <tr>
        <th>(1)</th>
        <td>∀A∈Ob <span class="category">C</span> F(id<sub>A</sub>) = id<sub>F(A)</sub></td>
        <td></td>
      </tr>
      <tr>
        <th>(m)</th>
        <td>∀f∈Mor<span class="category"><sub>C</sub></span>(A,B)∀g∈Mor<span class="category"><sub>C</sub></span>(B,C) 
          F(g∘f) = F(g) ∘ F(f)</td>
        <td>&quot;morph&quot;</td>
      </tr>
    </table>
    <p><span style="float: left; font-size: 200%">☡</span> Beware: F:<span class="category">C</span>→<span class="category">D</span> 
    is not a map, since <span class="category">C</span>,<span class="category">D</span> 
    are no sets (they are categories) and even Ob <span class="category">C</span>,Ob 
    <span class="category">D</span> need not be sets.</p>
  </dd>
  <dt>contra-<br>
    variant<br>
    functor</dt>
  <dd>A contravariant functor F:<span class="category">C</span>→<span class="category">D</span> 
    between two categories <span class="category">C</span> and <span class="category">D</span> 
    consists of a map F:Ob <span class="category">C</span>→Ob <span class="category">D</span> 
    and for each A,B∈Ob <span class="category">C</span> a map F:Mor<span class="category"><sub>C</sub></span>(A,B)→Mor<span class="category"><sub>D</sub></span>(F(B),F(A)) 
    that satisfies the following conditions
    <table>
      <tr>
        <th>(1)</th>
        <td>∀A∈Ob <span class="category">C</span> F(id<sub>A</sub>) = id<sub>F(A)</sub></td>
        <td></td>
      </tr>
      <tr>
        <th>(m')</th>
        <td>∀f∈Mor<span class="category"><sub>C</sub></span>(A,B)∀g∈Mor<span class="category"><sub>C</sub></span>(B,C) 
          F(g∘f) = F(f) ∘ F(g)</td>
        <td>&quot;contra-morph&quot;</td>
      </tr>
    </table>
    A contravariant functor F:<span class="category">C</span>→<span class="category">D</span> 
    is a covariant functor F:<span class="category">C</span>→<span class="category">D°</span> 
    (or F:<span class="category">C</span><span class="category">°</span>→<span class="category">D</span>).</dd>
  <dt id="naturalTransformation">natural<br>
    trans-<br>
    formation</dt>
  <dd>A natural transformation (or morphism of functors) α:F<span class="category"></span>→G 
    between the functors F,G:<span class="category">C</span>→<span class="category">D</span> 
    is a family <span class="seriesOperator">(</span>α<sub>C</sub>∈Mor<span class="category"><sub>D</sub></span>(F(C),G(C))<span class="seriesOperator">)</span><sub>C∈Ob 
    <span class="category">C</span></sub> of morphisms such that
    <div>
      ∀f∈Mor<sub><span class="category">C</span></sub>(C,C') G(f)∘α<sub>C</sub> 
      = α<sub>C'</sub>∘F(f)
    </div>
    <!-- @todo add the commutative diagram -->
    The functors <span class="category">C</span>→<span class="category">D</span> 
    form a category with natural transformations being the morphisms.<br>
    Remark: an isomorphism of functors is just a family of isomorphisms <span class="seriesOperator">(</span>α<sub>C</sub><sub></sub>∈Iso<span class="category"><sub>D</sub></span>(F(C),G(C))<span class="seriesOperator"></span><span class="seriesOperator">)</span><sub>C∈Ob 
    <span class="category">C</span></sub> with the above property (⇒ 
    especially F(C)≅G(C) ∧ G(f) = α<sub>C'</sub>∘F(f)∘α<sub>C</sub><sup>-1</sup>).</dd>
</dl>
<p>The elements of the monoid Mor<span class="category"><sub>C</sub></span>(A,A) 
are called <dfn>endomorphisms</dfn> of A. The elements of Mor<span class="category"><sub>C</sub></span>(A,B) 
that have an inverse in Mor<span class="category"><sub>C</sub></span>(B,A) are 
called <dfn>isomorphisms</dfn>. The elements of the group of isomorphisms in Mor<span class="category"><sub>C</sub></span>(A,A) 
are called <dfn>automorphisms</dfn>.</p>
<table width="100%" class="def">
  <tr>
    <td colspan="3">Let f∈Mor<span class="category"><sub>C</sub></span>(C,C') 
      be a morphism.</td>
  </tr>
  <tr>
    <td class="defTerm" id="monomorphism">monomorphism</td>
    <td>∀A∈Ob <span class="category">C</span> m<sub>A</sub>(f) injective</td>
    <td>&quot;f is left cancelable&quot;</td>
  </tr>
  <tr>
    <td></td>
    <td>⇔ f injective</td>
    <td>(if <span class="category">C</span>=<span class="category">Ens</span> )</td>
  </tr>
  <tr>
    <td class="defTerm" id="epimorphism">epimorphism</td>
    <td>∀A∈Ob <span class="category">C</span> m<sup>A</sup>(f) injective</td>
    <td>&quot;f is right cancelable&quot;</td>
  </tr>
  <tr>
    <td></td>
    <td>⇔ f surjective</td>
    <td>(if <span class="category">C</span>=<span class="category">Ens</span> )</td>
  </tr>
</table>
<dl class="def">
  <dt id="additive">additive</dt>
  <dd>A category <span class="category">C</span> is additive, if
    <table>
      <tr>
        <th>()</th>
        <td>∀A,B∈Ob <span class="category">C</span> Hom<sub><span class="category">C</span></sub>(A,B) 
          := Mor<sub><span class="category">C</span></sub>(A,B) is an Abelian 
          group</td>
        <td></td>
      </tr>
      <tr>
        <th>(d)</th>
        <td>∘ is distributive over +, i.e.
          <ul>
            <li>∀A,B,C∈Ob <span class="category">C</span> ∀f∈Hom<span class="category"><sub>C</sub></span>(B,C) 
              ∀g,h∈Hom<span class="category"><sub>C</sub></span>(A,B) f∘(g+h) 
              = (f∘g) + (f∘h)</li>
            <li>∀A,B,C∈Ob <span class="category">C</span> ∀f,g∈Hom<span class="category"><sub>C</sub></span>(B,C) 
              ∀h∈Hom<sub><span class="category">C</span></sub>(A,B) (f+g)∘h 
              = (f∘h) + (g∘h)</li>
          </ul>
        </td>
        <td>&quot;distributive&quot;</td>
      </tr>
    </table>
  </dd>
  <dt>additive</dt>
  <dd>A functor F:<span class="category">C</span>→<span class="category">D</span> 
    between two additive categories <span class="category">C</span> and <span class="category">D</span> 
    is additive, if
    <div>
      ∀A,B∈Ob <span class="category">C</span> F:Hom<sub><span class="category">C</span></sub>(A,B)<span class="category"></span>→Hom<span class="category"><sub>D</sub></span>(F(A),F(B)) 
      homomorphism of groups
    </div>
  </dd>
</dl>
<h3>Important Examples</h3>
<ol>
  <li id="opposite">
    <p>For every category <span class="category">C</span>, there is the <dfn>opposite</dfn> 
    (dual) category <span class="category">C°</span> obtained by &quot;turning 
    the arrows around&quot;, per Ob <span class="category">C°</span> := Ob <span class="category">C</span>, 
    and Mor<span class="category"><sub>C°</sub></span>(A,B) := Mor<span class="category"><sub>C</sub></span>(B,A) 
    whereas the identity morphisms are the same, and the composition is f∘<span class="category"><sub>C°</sub></span>g 
    := g∘<span class="category"><sub>C</sub></span>f.<br>
    <b>Duality Principle</b>: Any theorem holding for a category <span class="category">C</span> 
    also holds <i>(in <span class="category">C°</span>)</i> with <em>all</em> 
    arrows reversed.</p>
  </li>
  <li>
    <p>Categories together with functors form a category.</p>
  </li>
  <li>
    <p>Additive categories form a category together with additive functors.</p>
  </li>
  <li>
    <p>Functors of a fixed category together with their natural transformations 
    form a category (s.a.).</p>
  </li>
  <li id="hom-functor">
    <p>Let <span class="category">C</span> be a category. For each X∈Ob <span class="category">C</span> 
    there are two functors</p>
    <ul>
      <li>covariant hom-functor<br>
        m<sub>X</sub>:=Mor<span class="category"><sub>C</sub></span>(X,·):<span class="category">C</span>→<span class="category">Ens</span><br>
        Y ↦ m<sub>X</sub>(Y) := Y<sub>∗</sub>:=Mor<span class="category"><sub>C</sub></span>(X,Y)<br>
        (f∈Mor<span class="category"><sub>C</sub></span>(Y,Z)) ↦ <big>(</big>m<sub>X</sub>(f):Mor<span class="category"><sub>C</sub></span>(X,Y)→Mor<span class="category"><sub>C</sub></span>(X,Z); 
        g↦f∘g<big>)</big></li>
      <li>contravariant hom-functor<br>
        m<sup>X</sup>:=Mor<span class="category"><sub>C</sub></span>(·,X):<span class="category">C</span>→<span class="category">Ens</span><br>
        Y ↦ m<sup>X</sup>(Y) := Y<sup>∗</sup>:=Mor<span class="category"><sub>C</sub></span>(Y,X)<br>
        (f∈Mor<span class="category"><sub>C</sub></span>(Y,Z)) ↦ <big>(</big>m<sup>X</sup>(f):Mor<span class="category"><sub>C</sub></span>(Z,X)→Mor<span class="category"><sub>C</sub></span>(Y,X); 
        g↦g∘f<big>)</big></li>
    </ul>
    <p>They result from currying ∘. The properties of being a functor 
    coincides with the properties of morphisms (n) and (a), here. m<sup>X</sup> 
    is the opposite of m<sub>X</sub>. If <span class="category">C</span> is 
    additive we write Hom<span class="category"><sub>C</sub></span>(X,·):=h<sub>X</sub>:=m<sub>X</sub>, 
    and Hom<span class="category"><sub>C</sub></span>(·,X):=h<sup>X</sup>:=m<sup>X</sup> 
    for these additive functors in <span class="category">C</span>→<span class="category">Ab</span>. 
    The properties of h<sub>X</sub>,h<sup>X</sup> being additive coincides with 
    (d).</p>
  </li>
</ol>
<!--@todo check names of Y<sub>∗</sub>, and Y<sup>∗</sup> .-->
<h3>Additional definitions....</h3>
<dl>
  <dt id="Yoneda">Yoneda-Lemma</dt>
  <dd>Let <span class="category">F</span> be the category of functors <span class="category">C</span>→<span class="category">Ens</span><br />
    ⇒ ∀A,B∈Ob <span class="category">C</span> the following map is 
    bijective<br>
    <table>
      <tr>
        <td class="nameOfMap" rowspan="3">α:</td>
        <td class="leftOfMap">Mor<span class="category"><sub>C</sub></span>(A,B)</td>
        <td class="arrowOfMap">→̃</td>
        <td>Mor<span class="category"><sub>F</sub></span>(m<sub>B</sub>,m<sub>A</sub>)</td>
      </tr>
      <tr>
        <td class="leftOfMap">τ<sub>B</sub>(id<sub>B</sub>)</td>
        <td class="arrowOfMap">↤</td>
        <td class="rightOfMap">τ</td>
      </tr>
      <tr>
        <td class="leftOfMap">φ</td>
        <td class="arrowOfMap">↦</td>
        <td class="rightOfMap">
          <table>
            <tr>
              <td class="nameOfMap">α<sub>φ</sub>:</td>
              <td class="leftOfMap">m<sub>B</sub>
              <td class="arrowOfMap">→</td>
              <td class="rightOfMap">m<sub>A</sub></td>
            <tr>
              <td rowspan="2" class="nameOfMap">(α<sub>φ</sub>)<span class="category"><sub>C</sub></span>:</td>
              <td class="leftOfMap">Mor<span class="category"><sub>C</sub></span>(B,C)
              <td class="arrowOfMap">→</td>
              <td class="rightOfMap">Mor<span class="category"><sub>C</sub></span>(A,C)</td>
            </tr>
            <tr>
              <td class="leftOfMap">f</td>
              <td class="arrowOfMap">↦</td>
              <td class="rightOfMap">f∘φ</td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    <p>If <span class="category">C</span> is additive and <span class="category">F</span> 
    the category of (additive?) functors <span class="category">C</span>→<span class="category">Ab</span>, 
    then α is an isomorphism of groups.</dd>
</dl>
<dl class="def">
  <dt id="adjoint">adjoint</dt>
  <dd>F:<span class="category">C</span>→<span class="category">C'</span> 
    left-adjoint to G:<span class="category">C'</span>→<span class="category">C</span> 
    (and G right-adjoint to F) :⇔
    <div>
      m<sub>F</sub> := Mor<span class="category"><sub>C'</sub></span>(F(·),·) 
      ≅ m<sub>F</sub> := Mor<span class="category"><sub>C</sub></span>(·,G(·)) 
      =: m<sup>G</sup> in <span class="category">C</span><span class="category">°</span>×<span class="category">C'</span>→<span class="category">Ens</span>
    </div>
  </dd>
  <dt id="equivalentCategories">equivalent<br>
    categories</dt>
  <dd>F:<span class="category">C</span>→<span class="category">C'</span> is an 
    equivalence of categories :⇔
    <div>
      ∃G:<span class="category">C'</span>→<span class="category">C</span> 
      with F∘G≅id<sub class="category">C'</sub> ∧ G∘F≅id<sub class="category">C</sub>
    </div>
    <div>
      ⇒ F left-adjoint to G and conversely
    </div>
  </dd>
</dl>
<p>For the following definition, <span class="category">A</span> and <span class="category">A'</span> 
must be categories that have exact sequences (more precisely: Abelian 
categories).</p>
<dl class="def">
  <dt id="exact">exact</dt>
  <dd>F:<span class="category">A</span>→<span class="category">A'</span> is 
    exact :⇔ F:<span class="category">A</span>→<span class="category">A'</span> 
    is a (covariant) additive functor, and
    <table>
      <tr>
        <td>If</td>
        <td>0</td>
        <td>→</td>
        <td><span class="category">A'</span></td>
        <td>→<sup>α</sup></td>
        <td><span class="category">A</span></td>
        <td>→<sup>β</sup></td>
        <td><span class="category">A''</span></td>
        <td>→</td>
        <td>0</td>
        <td>is an exact sequence in <span class="category">A</span></td>
      </tr>
      <tr>
        <td>Then</td>
        <td>0</td>
        <td>→</td>
        <td>F(<span class="category">A'</span>)</td>
        <td>→<sup>F(α)</sup></td>
        <td>F(<span class="category">A</span>)</td>
        <td>→<sup>F(β)</sup></td>
        <td>F(<span class="category">A''</span>)</td>
        <td>→</td>
        <td>0</td>
        <td>is an exact sequence in <span class="category">A'</span></td>
      </tr>
    </table>
    That the image under F of the sequence (or any complex) is a complex, is 
    always true since F is a functor.</dd>
  <dt id="leftExact">left exact</dt>
  <dd>F:<span class="category">A</span>→<span class="category">A'</span> is 
    left exact :⇔ F:<span class="category">A</span>→<span class="category">A'</span> 
    is a (covariant) additive functor, and
    <table>
      <tr>
        <td>If</td>
        <td>0</td>
        <td>→</td>
        <td><span class="category">A'</span></td>
        <td>→<sup>α</sup></td>
        <td><span class="category">A</span></td>
        <td>→<sup>β</sup></td>
        <td><span class="category">A''</span></td>
        <td>→</td>
        <td>0</td>
        <td>is an exact sequence in <span class="category">A</span></td>
      </tr>
      <tr>
        <td>Then</td>
        <td>0</td>
        <td>→</td>
        <td>F(<span class="category">A'</span>)</td>
        <td>→<sup>F(α)</sup></td>
        <td>F(<span class="category">A</span>)</td>
        <td>→<sup>F(β)</sup></td>
        <td>F(<span class="category">A''</span>)</td>
        <td></td>
        <td></td>
        <td>is an exact sequence in <span class="category">A'</span></td>
      </tr>
    </table>
  </dd>
</dl>
<h2 id="universalElements">Universal Elements</h2>
<p>Let <span class="category">C</span> be a category.
<dl class="def">
  <dt id="initial">initial<br>
    object</dt>
  <dd>A∈Ob <span class="category">C</span> is an initial object :⇔ ∀B∈Ob 
    <span class="category">C</span> ∃!φ∈Mor<sub><span class="category">C</span></sub>(A,B)<br>
    initial objects are uniquely isomorph, i.e. each two initial objects A,B 
    have a unique isomorphism A→B.</dd>
  <dt id="terminal">terminal<br>
    object</dt>
  <dd>A∈Ob <span class="category">C</span> is a terminal object :⇔ ∀B∈Ob 
    <span class="category">C</span> ∃!φ∈Mor<sub><span class="category">C</span></sub>(B,A) 
    ⇔ A is an initial object in <span class="category">C°</span>.<br>
    terminal objects are uniquely isomorph, i.e. each two terminal objects A,B 
    have a unique isomorphism A→B.</dd>
  <dt id="presentable">presentable</dt>
  <dd>a covariant (resp. contravariant) functor F:<span class="category">C</span>→<span class="category">Ens</span> 
    is presentable :⇔ ∃A∈Ob <span class="category">C</span> F≅m<sub>A</sub> 
    (resp. F≅m<sup>A</sup>)<br>
    A is called presenting object for F.</dd>
  <dt id="universalElement">universal element</dt>
  <dd>If F:<span class="category">C</span>→<span class="category">Ens</span> 
    is a presentable covariant functor with a corresponding isomorphism of 
    functors α:m<sub>A</sub>→F, then u<sub>F</sub> := α<sub>A</sub>(id<sub>A</sub>) 
    ∈ F(A) is called universal element of F <!-- "das Bild vom Faulpelz" -->.
    <div>
      ⇒ ∀B∈Ob <span class="category">C</span> ∀x∈F(B) ∃!f∈Mor<sub class="category">C</sub>(A,B)=m<sub>A</sub>(B) 
      x = F(f)(u<sub>F</sub>)
      <ul>
        <li><small>(The converse is also true)</small></li>
        <li>(and this mapping α<sub>B</sub><sup>-1</sup>:x↦f is bijective)</li>
        <li>&nbsp;if F:<span class="category">C</span>→<span class="category">Ens</span> 
          is additive, then the α<sub>B</sub> are isomorphisms of groups</li>
      </ul>
    </div>
  </dd>
</dl>
Let F:<span class="category">C</span>→<span class="category">Ens</span> be a 
presentable covariant functor.
<ul>
  <li>presenting objects for F are uniquely isomorph. Precisely: for all 
    isomorphisms of functors α:m<sub>A</sub>→F, α':m<sub>A'</sub>→F ∃!φ:A<sub></sub>→A' 
    isomorphism with α∘α<sub>φ</sub> = α'. (See <a href="#Yoneda">Yoneda-Lemma</a>).</li>
  <li>an isomorphism of functors α:m<sub>A</sub>→F is uniquely determined by 
    its universal element, i.e. ∀x∈F(A) there is at most one α:m<sub>A</sub>→F 
    with α<sub>A</sub>(id<sub>A</sub>)=x.</li>
</ul>
<h2 id="products">Product and Coproduct</h2>
<dl class="def">
  Let <span class="category">C</span> be a category, and I be a set.
  <dt id="product">product</dt>
  <dd>P∈Ob <span class="category">C</span>, with the projectors π<sub>i</sub>∈Mor(P,A<sub>i</sub>) 
    for i∈I, is a product of the objects <span class="seriesOperator">(</span>A<sub>i</sub><span class="seriesOperator">)</span><sub>i∈I</sub>⊆Ob 
    <span class="category">C</span> :⇔ <center><big>(</big>∀C∈Ob <span class="category">C</span> 
    ∀<span class="seriesOperator">(</span>g<sub>i</sub><sub></sub>∈Mor<sub><span class="category">C</span></sub>(C,A<sub>i</sub>)<span class="seriesOperator">)</span><sub>i∈I</sub><br />
    ∃!g∈Mor<sub><span class="category">C</span></sub>(C,P) ∀i∈I π<sub>i</sub>∘g 
    = g<sub>i</sub> <big>)</big></center>Write: P = ∏<sub>i∈I</sub>A<sub>i</sub><sub><br>
    </sub>&quot;product is universally attracting&quot;, and it is just a 
    terminal object in a suitable category.</dd>
  <dt id="coproduct">coproduct</dt>
  <dd>S∈Ob <span class="category">C</span>, with the inclusions ι<sub>i</sub>∈Mor(A<sub>i</sub>,S) 
    for i∈I, is a coproduct of the objects <span class="seriesOperator">(</span>A<sub>i</sub><span class="seriesOperator">)</span><sub>i∈I</sub>⊆Ob 
    <span class="category">C</span> :⇔ <center><big>(</big>∀C∈Ob <span class="category">C</span> 
    ∀<span class="seriesOperator">(</span>g<sub>i</sub><sub></sub>∈Mor<sub><span class="category">C</span></sub>(A<sub>i</sub>,C)<span class="seriesOperator">)</span><sub>i∈I</sub><br />
    ∃!g∈Mor<sub><span class="category">C</span></sub>(S,C) ∀i∈I g∘ι<sub>i</sub> 
    = g<sub>i</sub> <big>)</big></center>Write: S = ∐<sub>i∈I</sub>A<sub>i</sub> 
    (= ∑<sub>i∈I</sub>A<sub>i</sub>, sometimes ⊕<sub>i∈I</sub>A<sub>i</sub>)<br>
    &quot;coproduct is universally repelling&quot;, and it is just an initial 
    object in&nbsp; a suitable category. A coproduct in <span class="category">C</span> 
    is just a product in <span class="category">C°</span>.</dd>
</dl>
<p>As terminal or initial objects, products and coproducts are uniquely 
determined up to a unique isomorphism.</p>

</body>

</html>
