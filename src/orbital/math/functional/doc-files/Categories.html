<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-gb">
<meta name="author" content="Andre Platzer">
<meta name="copyright" content="© 2002-2003 André Platzer">
<meta name="classification" content="Science/Mathematics/Category/Basics">
<title>Category theory</title>
<link rel="stylesheet" href="../../../../stylist.css" type="text/css" charset="utf-8" title="layout">
<link rel="stylesheet" href="../../../../math.css" type="text/css" charset="utf-8" title="layout">
</head>

<body class="unicode">

<h2>Contents</h2>
<ul>
  <li><a href="#categoriesAndFunctors">Categories and Functors</a>
  <li><a href="#universalElements">Universal Elements</a></li>
  <li><a href="#products">Product and Coproduct</a></li>
  <li><a href="#limits">Limits and Colimits</a></li>
</ul>
<h2 id="categoriesAndFunctors">Categories and Functors</h2>
<p>&quot;general abstract nonsense&quot;, &quot;functors leave complexes 
complex&quot;</p>
<dl class="def">
  <dt id="category">category</dt>
  <dd>A category <span class="categorie">C</span> consists of a family Ob <span class="categorie">C</span>               
    of <i>objects</i>, and for each <span class="objet">A</span>,<span class="objet">B</span>∈Ob               
    <span class="categorie">C</span> a set Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)               
    of <i>morphisms</i> between <span class="objet">A</span> and <span class="objet">B</span>               
    such that              
    <table>
      <tr>
        <td class="defID">r</td>
        <td class="defCond">∀<span class="objet">A</span>∈Ob <span class="categorie">C</span> 
          ∃id<span class="objet"><sub>A</sub></span>∈Mor<sub><span class="categorie">C</span></sub>(<span class="objet">A</span>,<span class="objet">A</span>)</td>
        <td class="defVerbal">reflexive, identity</td>
      </tr>
      <tr>
        <td class="defID">t</td>
        <td class="defCond">∀<span class="objet">A</span>,<span class="objet">B</span>,<span class="objet">C</span>∈Ob               
          <span class="categorie">C</span> ∃∘:Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">B</span>,<span class="objet">C</span>)×Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)→Mor<span class="categorie"><sub>C</sub></span>(A,<span class="objet">C</span>)               
          with</td>
        <td class="defVerbal">transitive, composition</td>
      </tr>
      <tr>
        <td class="defID" rowspan="2">n</td>
        <td class="defCond">∀<span class="objet">A</span>,<span class="objet">B</span>∈Ob 
          <span class="categorie">C</span> ∀g∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>) 
          g∘id<span class="objet"><sub>A</sub></span> = g</td>
        <td class="defVerbal" rowspan="2">neutral</td>
      </tr>
      <tr>
        <td class="defCond">∀<span class="objet">A</span>,<span class="objet">B</span>∈Ob 
          <span class="categorie">C</span> ∀f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">B</span>,A) 
          id<span class="objet"><sub>A</sub></span>∘f = f</td>
      </tr>
      <tr>
        <td class="defID">a</td>
        <td class="defCond">∀<span class="objet">A</span>,<span class="objet">B</span>,<span class="objet">C</span>,<span class="objet">D</span>∈Ob 
          <span class="categorie">C</span> ∀f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)∀g∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">B</span>,<span class="objet">C</span>)∀h∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">C</span>,<span class="objet">D</span>) 
          (h∘g)∘f = h∘(g∘f)</td>
        <td class="defVerbal">associative</td>
      </tr>
    </table>
    We usually assume that Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)               
    ∩ Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">C</span>,<span class="objet">D</span>)               
    = ∅ unless <span class="objet">A</span>=<span class="objet">C</span> ∧               
    B=<span class="objet">D</span>.<br>
    Write: f:<span class="objet">A</span>→<span class="objet">B</span> for               
    f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)
    <p><span style="float: left; font-size: 200%">☡</span> Beware: Unlike Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>), 
    Ob <span class="categorie">C</span> does not need to be a set of objects, 
    but only a class of objects. Nevertheless we formally write ∈,⊆ etc.</p>
  </dd>
  <dt id="functor">covariant<br>
    functor</dt>
  <dd>A covariant functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D</span> 
    between two categories <span class="categorie">C</span> and <span class="categorie">D</span> 
    consists of a map <span class="foncteur">F</span>:Ob <span class="categorie">C</span>→Ob 
    <span class="categorie">D</span> and for each <span class="objet">A</span>,<span class="objet">B</span>∈Ob 
    <span class="categorie">C</span> a map <span class="foncteur">F</span>:Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)→Mor<span class="categorie"><sub>D</sub></span>(<span class="foncteur">F</span>(<span class="objet">A</span>),<span class="foncteur">F</span>(<span class="objet">B</span>)) 
    that satisfies the following conditions
    <table>
      <tr>
        <td class="defID">1</td>
        <td class="defCond">∀<span class="objet">A</span>∈Ob <span class="categorie">C</span> 
          <span class="foncteur">F</span>(id<sub class="objet">A</sub>) = id<sub><span class="foncteur">F</span>(<span class="objet">A</span>)</sub></td>
        <td class="defVerbal">unital</td>
      </tr>
      <tr>
        <td class="defID">m</td>
        <td>∀f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)∀g∈Mor<span class="categorie"><sub>C</sub></span>(B,C) 
          <span class="foncteur">F</span>(g∘f) = <span class="foncteur">F</span>(g) 
          ∘ <span class="foncteur">F</span>(f)</td>
        <td class="defVerbal">morph</td>
      </tr>
    </table>
    <p><span style="float: left; font-size: 200%">☡</span> Beware: <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D</span> 
    is not a map, since <span class="categorie">C</span>,<span class="categorie">D</span> 
    are no sets (they are categories) and even Ob <span class="categorie">C</span>,Ob 
    <span class="categorie">D</span> need not be sets.</p>
  </dd>
  <dt>contra-<br>
    variant<br>
    functor</dt>
  <dd>A contravariant functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D</span>               
    between two categories <span class="categorie">C</span> and <span class="categorie">D</span>               
    consists of a map <span class="foncteur">F</span>:Ob <span class="categorie">C</span>→Ob               
    <span class="categorie">D</span> and for each <span class="objet">A</span>,<span class="objet">B</span>∈Ob               
    <span class="categorie">C</span> a map <span class="foncteur">F</span>:Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)→Mor<span class="categorie"><sub>D</sub></span>(<span class="foncteur">F</span>(<span class="objet">B</span>),<span class="foncteur">F</span>(<span class="objet">A</span>))               
    that satisfies the following conditions              
    <table>
      <tr>
        <td class="defID">1</td>
        <td class="defCond">∀<span class="objet">A</span>∈Ob <span class="categorie">C</span> 
          <span class="foncteur">F</span>(id<span class="objet"><sub>A</sub></span>) 
          = id<sub><span class="foncteur">F</span>(</sub><span class="objet"><sub>A</sub></span><sub>)</sub></td>
        <td class="defVerbal">unital</td>
      </tr>
      <tr>
        <td class="defID">m°</td>
        <td class="defCond">∀f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)∀g∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">B</span>,<span class="objet">C</span>)               
          <span class="foncteur">F</span>(g∘f) = <span class="foncteur">F</span>(f)               
          ∘ <span class="foncteur">F</span>(g)</td>              
        <td class="defVerbal">contra-morph</td>
      </tr>
    </table>
    A contravariant functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D</span>               
    is a covariant functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D°</span>               
    (or <span class="foncteur">F</span>:<span class="categorie">C</span><span class="categorie">°</span>→<span class="categorie">D</span>).</dd>              
  <dt id="naturalTransformation">natural<br>
    trans-<br>
    formation</dt>
  <dd><img class="annotatingDiagram" src="diagram/commutative/naturalTransformation.jpg" width="221" height="128"> 
    A natural transformation (or morphism of functors) <span class="transformationNaturelle">α</span>:<span class="foncteur">F</span>→<span class="foncteur">G</span>               
    between the functors <span class="foncteur">F</span>,<span class="foncteur">G</span>:<span class="categorie">C</span>→<span class="categorie">D</span>               
    is a family <span class="seriesOperator">(</span><span class="transformationNaturelle">α</span><span class="objet"><sub>C</sub></span>∈Mor<span class="categorie"><sub>D</sub></span>(<span class="foncteur">F</span>(<span class="objet">C</span>),<span class="foncteur">G</span>(<span class="objet">C</span>))<span class="seriesOperator">)</span><span class="objet"><sub>C</sub></span><sub>∈Ob               
    <span class="categorie">C</span></sub> of morphisms such that              
    <div>
      ∀f∈Mor<sub><span class="categorie">C</span></sub>(<span class="objet">C</span>,<span class="objet">C</span>')               
      <span class="foncteur">G</span>(f)∘<span class="transformationNaturelle">α</span><span class="objet"><sub>C</sub></span> 
      = <span class="transformationNaturelle">α</span><span class="objet"><sub>C'</sub></span>∘<span class="foncteur">F</span>(f)              
    </div>
    <!-- @todo add the commutative diagram -->
    The functors <span class="categorie">C</span>→<span class="categorie">D</span>               
    form a category with natural transformations being the morphisms.<br>              
    Remark: an isomorphism of functors is just a family of isomorphisms <span class="seriesOperator">(</span><span class="transformationNaturelle">α</span><span class="objet"><sub>C</sub></span>∈Iso<span class="categorie"><sub>D</sub></span>(<span class="foncteur">F</span>(<span class="objet">C</span>),<span class="foncteur">G</span>(<span class="objet">C</span>))<span class="seriesOperator"></span><span class="seriesOperator">)</span><span class="objet"><sub>C</sub></span><sub>∈Ob               
    <span class="categorie">C</span></sub> with the above property (⇒               
    especially <span class="foncteur">F</span>(<span class="objet">C</span>)≅<span class="foncteur">G</span>(<span class="objet">C</span>)               
    ∧ <span class="foncteur">G</span>(f) = <span class="transformationNaturelle">α</span><span class="objet"><sub>C'</sub></span>∘<span class="foncteur">F</span>(f)∘<span class="transformationNaturelle">α</span><span class="objet"><sub>C</sub></span><sup>-1</sup>).</dd>              
</dl>
<p>The elements of the monoid Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">A</span>) 
are called <dfn>endomorphisms</dfn> of A. The elements of Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>) 
that have an inverse in Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">B</span>,<span class="objet">A</span>) 
are called <dfn>isomorphisms</dfn>. The elements of the group of isomorphisms in 
Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">A</span>) 
are called <dfn>automorphisms</dfn>.</p>
<table width="100%" class="def">
  <tr>
    <td colspan="3">Let f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">A'</span>) 
      be a morphism.</td>
  </tr>
  <tr>
    <td class="defTerm" id="monomorphism"><dfn>monomorphism</dfn></td>
    <td class="defCond">∀<span class="objet">B</span>∈Ob <span class="categorie">C</span> 
      <span class="foncteur">m<sub class="objet">B</sub></span>(f) injective</td>
    <td class="defVerbal">f is left cancelable</td>
  </tr>
  <tr>
    <td></td>
    <td class="defCond">⇔ f injective</td>
    <td>(if <span class="categorie">C</span>=<span class="categorie">Ens</span> 
      )</td>
  </tr>
  <tr>
    <td class="defTerm" id="epimorphism"><dfn>epimorphism</dfn></td>
    <td class="defCond">∀<span class="objet">B</span>∈Ob <span class="categorie">C</span> 
      <span class="foncteur">m<sup class="objet">B</sup></span>(f) injective</td>
    <td class="defVerbal">f is right cancelable</td>
  </tr>
  <tr>
    <td></td>
    <td>⇔ f surjective</td>
    <td>(if <span class="categorie">C</span>=<span class="categorie">Ens</span> 
      )</td>
  </tr>
</table>

<dl class="def">
  <dt id="kernel">kernel &le; equalizer</dt>
  <dd>i:<span class="objet">X</span>&rarr;<span class="objet">A</span> is a kernel of  
     f:<span class="objet">A</span>&rarr;<span class="objet">B</span> :&hArr;   
     f∘i = 0, and &forall;j:<span class="objet">X'</span>&rarr;<span class="objet">A</span> with f∘j=0 
     &exist;!j':<span class="objet">X'</span>&rarr;<span class="objet">X</span> such that the diagram commutes 
     <img class="annotatingDiagram" src="diagram/commutative/kernel.png" width="164" height="102">.
     <br />
     Write: i = ker(f) 
   </dd>
  <dt id="cokernel">cokernel &le; coequalizer</dt>
  <dd>p:<span class="objet">B</span>&rarr;<span class="objet">Y</span> is a kernel of  
     f:<span class="objet">A</span>&rarr;<span class="objet">B</span> :&hArr;   
     p∘f = 0, and &forall;j:<span class="objet">B</span>&rarr;<span class="objet">Y'</span> with j∘f=0 
     &exist;!j':<span class="objet">Y</span>&rarr;<span class="objet">Y'</span> such that the diagram commutes 
     <img class="annotatingDiagram" src="diagram/commutative/cokernel.png" width="158" height="111">.
     <br />
     Write: p = coker(f) 
   </dd>
</dl>

<dl class="def">
  <dt id="additive">additive</dt>
  <dd>A category <span class="categorie">C</span> is additive, if      
    <table>
      <tr>
        <td class="defID"></td>
        <td class="defCond">∀<span class="objet">A</span>,<span class="objet">B</span>∈Ob 
          <span class="categorie">C</span> Hom<sub><span class="categorie">C</span></sub>(<span class="objet">A</span>,<span class="objet">B</span>) 
          := Mor<sub><span class="categorie">C</span></sub>(<span class="objet">A</span>,<span class="objet">B</span>) 
          is an Abelian(<a href="../../doc-files/AlgebraicStructures.html#commutativeMagmaHom">!</a>) 
          group</td>
        <td class="defVerbal"></td>
      </tr>
      <tr>
        <td class="defID">d</td>
        <td class="defCond">∘ is distributive over +, i.e. Hom<sub><span class="categorie">C</span></sub>(·,<span class="objet">B</span>)      
          and Hom<sub><span class="categorie">C</span></sub>(<span class="objet">B</span>,·)      
          are functors <span class="categorie">C</span>→<span class="categorie">Ab</span>     
          <ul>
            <li>∀A,B,C∈Ob <span class="categorie">C</span> ∀f∈Hom<span class="categorie"><sub>C</sub></span>(B,C) 
              ∀g,h∈Hom<span class="categorie"><sub>C</sub></span>(A,B) 
              f∘(g+h) = (f∘g) + (f∘h)</li>
            <li>∀A,B,C∈Ob <span class="categorie">C</span> ∀f,g∈Hom<span class="categorie"><sub>C</sub></span>(B,C) 
              ∀h∈Hom<sub><span class="categorie">C</span></sub>(A,B) 
              (f+g)∘h = (f∘h) + (g∘h)</li>
          </ul>
        </td>
        <td class="defVerbal">distributive</td>
      </tr>
    </table>
  </dd>
  <dt>additive</dt>
  <dd>A functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D</span> 
    between two additive categories <span class="categorie">C</span> and <span class="categorie">D</span> 
    is additive, if
    <div>
      ∀<span class="objet">A</span>,<span class="objet">B</span>∈Ob <span class="categorie">C</span> 
      <span class="foncteur">F</span>:Hom<sub><span class="categorie">C</span></sub>(<span class="objet">A</span>,<span class="objet">B</span>)<span class="categorie"></span>→Hom<span class="categorie"><sub>D</sub></span>(<span class="foncteur">F</span>(<span class="objet">A</span>),<span class="foncteur">F</span>(<span class="objet">B</span>)) 
      homomorphism of groups
    </div>
    ⇒ ∀<span class="foncteur">G</span>≅<span class="foncteur">F</span> <span class="foncteur">G</span> 
    is additive</dd>
  <dt id="faithful">faithful</dt>
  <dd>A functor <span class="foncteur">F</span> is faithful, if it is injective on maps.
  </dd>
  <dt id="full">full</dt>
  <dd>A functor <span class="foncteur">F</span> is full, if it is surjective on maps.
  </dd>
  <dt id="Ableian">Abelian</dt>
  <dd>A category <span class="categorie">C</span> is Abelian, if   
    <table>
      <tr>
        <td class="defID"></td>
        <td class="defCond"><span class="categorie">C</span> is additive</td>
        <td class="defVerbal"></td>
      </tr>
      <tr>
        <td class="defID"></td>
        <td class="defCond">all coproducts, kernels and cokernels exist. (&rArr; short exact sequences exist)
        </td>
        <td class="defVerbal"></td>
      </tr>
      <tr>
        <td class="defID"></td>
        <td class="defCond">Isomorphism Theorem.
        </td>
        <td class="defVerbal"></td>
      </tr>
      <tr>
        <td class="defID"></td>
        <td class="defCond">every monomorphism is the kernel of its cokernel (m = ker coker m),<br> 
          every epimorphism the cokernel of its kernel (f = coker ker f). 
        </td>
        <td class="defVerbal">normal</td>
      </tr>
    </table>
    &hArr;
    <table>
      <tr>
        <td class="defID"></td>
        <td class="defCond"><span class="categorie">C</span> has a <a hre="#zero">zero object</a></td>
        <td class="defVerbal"></td>
      </tr>
      <tr>
        <td class="defID"></td>
        <td class="defCond">all finitary limits and colimits exist
        </td>
        <td class="defVerbal"></td>
      </tr>
      <tr>
        <td class="defID"></td>
        <td class="defCond">every monomorphism is the kernel of its cokernel (m = ker coker m),<br> 
          every epimorphism the cokernel of its kernel (f = coker ker f). 
        </td>
        <td class="defVerbal">normal</td>
      </tr>
    </table>
  </dd>
</dl>
<h3>Important Examples</h3>
<ol>
  <li id="opposite">
    <p>For every category <span class="categorie">C</span>, there is the <dfn>opposite</dfn>           
    (dual) category <span class="categorie">C°</span> obtained by &quot;turning           
    the arrows around&quot;, per Ob <span class="categorie">C°</span> := Ob <span class="categorie">C</span>,           
    and Mor<span class="categorie"><sub>C°</sub></span>(A,B) := Mor<span class="categorie"><sub>C</sub></span>(B,A),           
    whereas the identity morphisms are the same, and the composition is f∘<span class="categorie"><sub>C°</sub></span>g           
    := g∘<span class="categorie"><sub>C</sub></span>f.<br>          
    <b>Duality Principle</b>: Any theorem holding for a category <span class="categorie">C</span>           
    also holds <i>(in <span class="categorie">C°</span>)</i> with <em>all</em>           
    arrows reversed.</p>          
  </li>
  <li>
    <p>Categories together with functors form a category.</p>
  </li>
  <li>
    <p>Additive categories form a category together with additive functors.</p>
  </li>
  <li>
    <p>Functors of fixed categories together with their natural transformations 
    form a category.</p>
  </li>
  <li id="hom-functor">
    <p>Let <span class="categorie">C</span> be a category. For each X∈Ob <span class="categorie">C</span> 
    there are two functors</p>
    <ul>
      <li>covariant hom-functor          
        <table>
          <tr>
            <td class="nameOfMap" rowspan="3"><span class="foncteur">m<sub>X</sub></span>:=Mor<span class="categorie"><sub>C</sub></span>(X,·)</td>
            <td class="leftOfMap"><span class="categorie">C</span></td>
            <td class="arrowOfMap">→</td>
            <td class="rightOfMap"><span class="categorie">Ens</span></td>
          </tr>
          <tr>
            <td class="leftOfMap"><span class="objet">Y</span></td>
            <td class="arrowOfMap">↦</td>
            <td class="rightOfMap">Y<sub>∗</sub>:=Mor<span class="categorie"><sub>C</sub></span>(X,Y)</td>
          </tr>
          <tr>
            <td class="leftOfMap">(f∈Mor<span class="categorie"><sub>C</sub></span>(Y,Z))</td>
            <td class="arrowOfMap">↦</td>
            <td class="rightOfMap"><big>(</big>Mor<span class="categorie"><sub>C</sub></span>(X,Y)→Mor<span class="categorie"><sub>C</sub></span>(X,Z); 
              g↦f∘g<big>)</big></td>
          </tr>
        </table>
      </li>
      <li>contravariant hom-functor<br>          
        <table>
          <tr>
            <td class="nameOfMap" rowspan="3"><span class="foncteur">m<sup>X</sup></span>:=Mor<span class="categorie"><sub>C</sub></span>(·,X)</td>
            <td class="leftOfMap"><span class="categorie">C</span></td>
            <td class="arrowOfMap">→</td>
            <td class="rightOfMap"><span class="categorie">Ens</span></td>
          </tr>
          <tr>
            <td class="leftOfMap"><span class="objet">Y</span></td>
            <td class="arrowOfMap">↦</td>
            <td class="rightOfMap">Y<sup>∗</sup>:=Mor<span class="categorie"><sub>C</sub></span>(Y,X)</td>
          </tr>
          <tr>
            <td class="leftOfMap">(f∈Mor<span class="categorie"><sub>C</sub></span>(Y,Z))</td>
            <td class="arrowOfMap">↦</td>
            <td class="rightOfMap"><big>(</big>Mor<span class="categorie"><sub>C</sub></span>(Z,X)→Mor<span class="categorie"><sub>C</sub></span>(Y,X); 
              g↦g∘f<big>)</big></td>
          </tr>
        </table>
      </li>
    </ul>
    <p>They result from currying ∘. The properties of being a functor           
    coincides with the properties of morphisms (n) and (a), here. <span class="foncteur">m<sup>X</sup></span>           
    is the opposite of <span class="foncteur">m<sub>X</sub></span>. If <span class="categorie">C</span>           
    is additive we write <span class="foncteur">Hom<span class="categorie"><sub>C</sub></span></span>(X,·):=<span class="foncteur">h<sub>X</sub></span>:=<span class="foncteur">m<sub>X</sub></span>,           
    and <span class="foncteur">Hom<span class="categorie"><sub>C</sub></span></span>(·,X):=<span class="foncteur">h<sup>X</sup></span>:=<span class="foncteur">m<sup>X</sup></span>           
    for these (now additive) functors in <span class="categorie">C</span>→<span class="categorie">Ab</span>.           
    The properties of being additive coincides with (d).</p>          
  </li>
  <li>
	Let <span class="categorie">C</span> be a category, and <span class="object">S</span>&isin;Ob <span class="categorie">C</span>.          
	Then <span class="categorie">C/<span class="object">S</span></span> is the category of <dfn><span class="object">S</span>-objects</dfn> in <span class="categorie">C</span>        
	with<br />        
	Ob <span class="categorie">C/<span class="object">S</span></span> := {(X,f) &brvbar; X&isin;Ob <span class="categorie">C</span>, f &isin;Mor<sub class=categorie">C</sub>(X,S)} <br />        
	Mor<sub class="categorie">C/<span class="object">S</span></sub>((X,f),(Y,g)) := {&phi;&isin;Mor<sub class="categorie">C</sub>(X,Y) &brvbar; f = g ∘ &phi;}        
    </li>
</ol>
<!--@todo check names of Y<sub>∗</sub>, and Y<sup>∗</sup> .-->
<h3>Further Terminology</h3>
<dl>
  <dt id="Yoneda">Yoneda-Lemma</dt>
  <dd>Let <span class="categorie">F</span> be the category of functors <span class="categorie">C</span>→<span class="categorie">Ens</span><br />          
    ⇒ ∀A,B∈Ob <span class="categorie">C</span> the following map is           
    bijective<br>
    <table>
      <tr>
        <td class="nameOfMap" rowspan="3">α</td>
        <td class="leftOfMap">Mor<span class="categorie"><sub>C</sub></span>(A,B)</td>
        <td class="arrowOfMap">→̃</td>
        <td class="rightOfMap">Mor<span class="categorie"><sub>F</sub></span>(<span class="foncteur">m<sub class="objet">B</sub></span>,<span class="foncteur">m<sub class="objet">A</sub></span>)</td>
      </tr>
      <tr>
        <td class="leftOfMap"><span class="transformationNaturelle">τ</span><sub>B</sub>(<span class="morphisme">id<sub>B</sub></span>)</td>
        <td class="arrowOfMap">↤</td>
        <td class="rightOfMap"><span class="transformationNaturelle">τ</span></td>
      </tr>
      <tr>
        <td class="leftOfMap">φ</td>
        <td class="arrowOfMap">↦</td>
        <td class="rightOfMap">
          <table>
            <tr>
              <td class="nameOfMap"><span class="transformationNaturelle">α<sub>φ</sub></span></td>
              <td class="leftOfMap"><span class="foncteur">m<sub class="objet">B</sub></span>
              <td class="arrowOfMap">→</td>
              <td class="rightOfMap"><span class="foncteur">m<sub class="objet">A</sub></span></td>
            <tr>
              <td rowspan="2" class="nameOfMap">(<span class="transformationNaturelle">α<sub>φ</sub></span>)<span class="categorie"><sub>C</sub></span></td>
              <td class="leftOfMap">Mor<span class="categorie"><sub>C</sub></span>(B,C)
              <td class="arrowOfMap">→</td>
              <td class="rightOfMap">Mor<span class="categorie"><sub>C</sub></span>(A,C)</td>
            </tr>
            <tr>
              <td class="leftOfMap">f</td>
              <td class="arrowOfMap">↦</td>
              <td class="rightOfMap">f∘φ</td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    <p>If <span class="categorie">C</span> is additive and <span class="categorie">F</span>           
    the category of (additive?) functors <span class="categorie">C</span>→<span class="categorie">Ab</span>,           
    then α is an isomorphism of groups.</dd>          
</dl>
<dl class="def">
  <dt id="adjoint">adjoint</dt>
  <dd><img class="annotatingDiagram" src="diagram/commutative/adjoint.jpg" width="511" height="302"> 
    <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">C'</span>           
    left-adjoint to <span class="foncteur">G</span>:<span class="categorie">C'</span>→<span class="categorie">C</span>           
    (and <span class="foncteur">G</span> right-adjoint to <span class="foncteur">F</span>)           
    :⇔
    <div>
      <span class="foncteur">m<sub><span class="foncteur">F</span></sub></span> 
      := Mor<span class="categorie"><sub>C'</sub></span>(<span class="foncteur">F</span>(·),·)           
      ≅ Mor<span class="categorie"><sub>C</sub></span>(·,<span class="foncteur">G</span>(·))           
      =: <span class="foncteur">m<sup><span class="foncteur">G</span></sup></span>           
      in <span class="categorie">C</span><span class="categorie">°</span>×<span class="categorie">C'</span>→<span class="categorie">Ens</span>          
    </div>
    &quot;what F does to the source (adding primes) is what G does to the domain           
    (removing primes)&quot;</dd>          
  <dt id="equivalentCategories">equivalent<br>
    categories</dt>
  <dd><span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">C'</span> 
    is an equivalence of categories :⇔
    <div>
      ∃<span class="foncteur">G</span>:<span class="categorie">C'</span>→<span class="categorie">C</span> 
      with <span class="foncteur">F</span>∘<span class="foncteur">G</span>≅id<sub class="categorie">C'</sub> 
      ∧ <span class="foncteur">G</span>∘<span class="foncteur">F</span>≅id<sub class="categorie">C</sub>
    </div>
    <div>
      ⇒ <span class="foncteur">F</span> left-adjoint to <span class="foncteur">G</span> 
      and conversely
    </div>
    Ismomorphic categories are equivalent.</dd>
</dl>
<p>For the following definition, <span class="categorie">A</span> and <span class="categorie">A'</span> 
must be categories that have exact sequences (more precisely: Abelian 
categories) <!-- <source>Pareigis, 4.2</source> -->.</p>
<dl class="def">
  <dt id="exact">exact</dt>
  <dd><span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span> 
    is exact :⇔ <span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span>           
    is a (covariant) additive functor, and          
    <table>
      <tr>
        <td>If</td>
        <td>0</td>
        <td>→</td>
        <td><span class="categorie">A'</span></td>
        <td>→<sup>α</sup></td>
        <td><span class="categorie">A</span></td>
        <td>→<sup>β</sup></td>
        <td><span class="categorie">A''</span></td>
        <td>→</td>
        <td>0</td>
        <td>is an exact sequence in <span class="categorie">A</span></td>
      </tr>
      <tr>
        <td>Then</td>
        <td>0</td>
        <td>→</td>
        <td><span class="foncteur">F</span>(<span class="categorie">A'</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(α)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(β)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A''</span>)</td>
        <td>→</td>
        <td>0</td>
        <td>is an exact sequence in <span class="categorie">A'</span></td>
      </tr>
    </table>
    That the image under <span class="foncteur">F</span> of the sequence (or any           
    complex) is a complex, is always true since <span class="foncteur">F</span>           
    is a functor.</dd>          
  <dt id="leftExact">left exact</dt>
  <dd><span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span> 
    is left exact :⇔ <span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span>           
    is a (covariant) additive functor, and          
    <table>
      <tr>
        <td>If</td>
        <td>0</td>
        <td>→</td>
        <td><span class="categorie">A'</span></td>
        <td>→<sup>α</sup></td>
        <td><span class="categorie">A</span></td>
        <td>→<sup>β</sup></td>
        <td><span class="categorie">A''</span></td>
        <td>(→</td>
        <td>0)</td>
        <td>is an exact sequence in <span class="categorie">A</span></td>
      </tr>
      <tr>
        <td>Then</td>
        <td>0</td>
        <td>→</td>
        <td><span class="foncteur">F</span>(<span class="categorie">A'</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(α)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(β)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A''</span>)</td>
        <td></td>
        <td></td>
        <td>is an exact sequence in <span class="categorie">A'</span>.</td>
      </tr>
    </table>
  </dd>
  <dt id="rightExact">right exact</dt>
  <dd><span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span> 
    is right exact :⇔ <span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span>           
    is a (covariant) additive functor, and          
    <table>
      <tr>
        <td>If</td>
        <td>(0</td>
        <td>→)</td>
        <td><span class="categorie">A'</span></td>
        <td>→<sup>α</sup></td>
        <td><span class="categorie">A</span></td>
        <td>→<sup>β</sup></td>
        <td><span class="categorie">A''</span></td>
        <td>→</td>
        <td>0</td>
        <td>is an exact sequence in <span class="categorie">A</span></td>
      </tr>
      <tr>
        <td>Then</td>
        <td></td>
        <td></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A'</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(α)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(β)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A''</span>)</td>
        <td>→</td>
        <td>0</td>
        <td>is an exact sequence in <span class="categorie">A'</span>.</td>
      </tr>
    </table>
    <span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span> 
    is right exact ⇔ <span class="foncteur">F</span>:<span class="categorie">A°</span>→<span class="categorie">A'°</span>           
    is left exact.</dd>          
  <dt id="injective">injective</dt>
  <dd><span class="objet">I</span>&isin;Ob <span class="categorie">A</span> is injective :&hArr; <span class="foncteur">Hom<span class="categorie"><sub>A</sub></span></span>(·,<span class="objet">I</span>) exact   
   <br />
   &hArr;  &forall;<span class="objet">A'</span>&sube;<span class="objet">A</span> &isin; <span class="categorie">A</span> &forall;<span class="morphisme">&alpha;'</span>:A'&rarr;I &exist;<span class="morphisme">&alpha;</span>:A&rarr;I which is a continuation of &alpha;'.   
   <br />
   <span class="categorie">A</span> has sufficiently many injective objects :&hArr; each object is a subobject of an injective object.    
   </dd>    
  <dt id="projective">projective</dt>
  <dd><span class="objet">P</span>&isin;Ob <span class="categorie">A</span> is projective :&hArr; <span class="foncteur">Hom<span class="categorie"><sub>A</sub></span></span>(<span class="objet">P</span>,·) exact         
   <br />
   &hArr;  &forall;<span class="morphisme">&beta;</span>:B&rarr;B'' surjective &forall;<span class="morphisme">&gamma;</span>:P&rarr;B''   
   &exist;<span class="morphisme">γ̃</span>:P&rarr;B which is a lifting, i.e. &beta;∘γ̃ = &gamma;.   
   <br />
   <span class="categorie">A</span> has sufficiently many projective objects :&hArr; each object is a quotient of a projective object.    
  </dd>
</dl>
<h2 id="universalElements">Universal Elements</h2>
<p>Let <span class="categorie">C</span> be a category.
<dl class="def">
  <dt id="terminal">terminal<br>
    object</dt>
  <dd><img class="annotatingDiagram" src="diagram/commutative/terminal.jpg" width="128" height="82"> 
    A∈Ob <span class="categorie">C</span> is a terminal object :⇔ ∀B∈Ob <span class="categorie">C</span>          
    ∃!φ∈Mor<sub><span class="categorie">C</span></sub>(B,A) ⇔ A is an          
    initial object in <span class="categorie">C°</span>.<br>         
    terminal objects are uniquely isomorph, i.e. each two terminal objects A,B          
    have a unique isomorphism A→B.<br> 
    Terminal objects are the limits of the empty category.</dd>
  <dt id="initial">initial<br>
    object</dt>
  <dd><img class="annotatingDiagram" src="diagram/commutative/initial.jpg" width="102" height="89"> 
    A∈Ob <span class="categorie">C</span> is an initial object :⇔ ∀B∈Ob <span class="categorie">C</span>          
    ∃!φ∈Mor<sub><span class="categorie">C</span></sub>(A,B)<br>         
    initial objects are uniquely isomorph, i.e. each two initial objects A,B          
    have a unique isomorphism A→B.          
    Initial objects are the colimits of the empty category.
    <!-- free object iff initial object? -->
  </dd>
  <dt id="zero">zero<br>
    object</dt>
  <dd>A∈Ob <span class="categorie">C</span> is a zero object :⇔ A is an initial and terminal object.</dd>
  
  <dt id="presentable">presentable</dt>
  <dd>a covariant (resp. contravariant) functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">Ens</span> 
    is presentable :⇔ ∃A∈Ob <span class="categorie">C</span> <span class="foncteur">F</span>≅<span class="foncteur">m<sub>A</sub></span> 
    (resp. <span class="foncteur">F</span>≅<span class="foncteur">m<sup>A</sup></span>)<br>
    A is called presenting object for <span class="foncteur">F</span>.</dd>
  <dt id="universalElement">universal element</dt>
  <dd>If <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">Ens</span>         
    is a presentable covariant functor with a corresponding isomorphism of         
    functors <span class="transformationNaturelle">α</span>:<span class="foncteur">m<sub>A</sub></span>→<span class="foncteur">F</span>,         
    then u<sub><span class="foncteur">F</span></sub> := <span class="transformationNaturelle">α</span><sub>A</sub>(id<sub>A</sub>)         
    ∈ <span class="foncteur">F</span>(A) is called universal element of <span class="foncteur">F</span> <!-- "das Bild vom Faulpelz" -->.        
    <div>
      ⇒ ∀B∈Ob <span class="categorie">C</span> ∀x∈<span class="foncteur">F</span>(B)         
      ∃!f∈Mor<sub class="categorie">C</sub>(A,B)=<span class="foncteur">m<sub>A</sub></span>(B)         
      x = <span class="foncteur">F</span>(f)(u<sub><span class="foncteur">F</span></sub>)        
      <ul>
        <li><small>(The converse is also true)</small></li>
        <li>&nbsp;if <span class="categorie">C</span> and <span class="categorie">Ens</span>         
          (then <span class="categorie">Ab</span>) are additive, then (<span class="foncteur">m<sub>A</sub></span>,<span class="foncteur">F</span>         
          are and) the <span class="transformationNaturelle">α</span><sub>B</sub>         
          are isomorphisms of groups.</li>        
        <li>More generally, if <span class="foncteur">F</span> (on morphisms) is         
          a homomorphism of a law + that <span class="transformationNaturelle"></span>∘         
          is distributive over, then the <span class="transformationNaturelle">α</span><sub>B</sub>         
          are isomorphisms of +.</li>        
      </ul>
    </div>
  </dd>
</dl>
Let <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">Ens</span>               
be a presentable covariant functor.              
<ul>
  <li>presenting objects for <span class="foncteur">F</span> are uniquely         
    isomorph. Precisely: for all isomorphisms of functors <span class="transformationNaturelle">α</span>:<span class="foncteur">m<sub>A</sub></span>→<span class="foncteur">F</span>,         
    <span class="transformationNaturelle">α'</span>:<span class="foncteur">m<sub>A</sub></span><sub>'</sub>→<span class="foncteur">F</span> 
    ∃!φ:A<sub></sub>→A' isomorphism with <span class="transformationNaturelle">α</span>∘α<sub>φ</sub>         
    = <span class="transformationNaturelle">α</span>'. (Because of <a href="#Yoneda">Yoneda-Lemma</a>).</li>        
  <li>an isomorphism of functors <span class="transformationNaturelle">α</span>:<span class="foncteur">m<sub>A</sub></span>→<span class="foncteur">F</span>         
    is uniquely determined by its universal element, i.e. ∀u∈<span class="foncteur">F</span>(A)         
    there is at most one <span class="transformationNaturelle">α</span>:<span class="foncteur">m<sub>A</sub></span>→<span class="foncteur">F</span>         
    with <span class="transformationNaturelle">α</span><sub>A</sub>(id<sub>A</sub>)=u.</li>        
</ul>
<h2 id="products">Product and Coproduct</h2>
<dl class="def">
  Let <span class="categorie">C</span> be a category, and I be a set.        
  <dt id="product">product &le; limit</dt>
  <dd><img class="annotatingDiagram" src="diagram/commutative/product.jpg" width="149" height="148"> 
    P∈Ob <span class="categorie">C</span>, with the projectors π<sub>i</sub>∈Mor(P,A<sub>i</sub>)         
    for i∈I, is a product of the objects <span class="seriesOperator">(</span>A<sub>i</sub><span class="seriesOperator">)</span><sub>i∈I</sub>⊆Ob         
    <span class="categorie">C</span> :⇔        
    <div style="text-align: center">
      <big>(</big>∀C∈Ob <span class="categorie">C</span> ∀<span class="seriesOperator">(</span>g<sub>i</sub><sub></sub>∈Mor<sub><span class="categorie">C</span></sub>(C,A<sub>i</sub>)<span class="seriesOperator">)</span><sub>i∈I</sub><br />        
      ∃!g∈Mor<sub><span class="categorie">C</span></sub>(C,P) ∀i∈I π<sub>i</sub>∘g         
      = g<sub>i</sub> <big>)</big>        
    </div>
    Write: P = ∏<sub>i∈I</sub>A<sub>i</sub><br>        
    &quot;product is universally attracting&quot;, and 
    product is the presenting object of the contravariant functor <span class="categorie">C</span>&rarr;<span class="categorie">Ens</span>; C ↦ Mor(C,A<sub>1</sub>)×Mor(C,A<sub>2</sub>) 
    with universal projector maps π<sub>i</sub>. Furthermore, it is just a terminal 
    object in a suitable category. Products are the limits of a functor from a
    discrete category (i.e. which only has identity morphisms and thus
    reduces to a family of objects).</dd> 
  <dt id="coproduct">coproduct &le; colimit</dt>
  <dd><img class="annotatingDiagram" src="diagram/commutative/coproduct.jpg" width="176" height="159"> 
    S∈Ob <span class="categorie">C</span>, with the inclusions ι<sub>i</sub>∈Mor(A<sub>i</sub>,S)         
    for i∈I, is a coproduct of the objects <span class="seriesOperator">(</span>A<sub>i</sub><span class="seriesOperator">)</span><sub>i∈I</sub>⊆Ob         
    <span class="categorie">C</span> :⇔        
    <div style="text-align: center">
      <big>(</big>∀C∈Ob <span class="categorie">C</span> ∀<span class="seriesOperator">(</span>g<sub>i</sub><sub></sub>∈Mor<sub><span class="categorie">C</span></sub>(A<sub>i</sub>,C)<span class="seriesOperator">)</span><sub>i∈I</sub><br />        
      ∃!g∈Mor<sub><span class="categorie">C</span></sub>(S,C) ∀i∈I g∘ι<sub>i</sub>         
      = g<sub>i</sub> <big>)</big>        
    </div>
    Write: S = ∐<sub>i∈I</sub>A<sub>i</sub> (= ∑<sub>i∈I</sub>A<sub>i</sub>,         
    sometimes ⊕<sub>i∈I</sub>A<sub>i</sub>)<br>        
    &quot;coproduct is universally repelling&quot;, and it is just an initial         
    object in&nbsp; a suitable category. A coproduct in <span class="categorie">C</span>         
    is just a product in <span class="categorie">C°</span>.</dd>        
  <dt id="fibreProduct">fibred-product</dt>
  <dd>X &times;<sub>S</sub> Y is a fibred product of X &isin; Ob <span class="categorie">C</span> and Y&isin;Ob <span class="categorie">C</span>      
    over <span class="object">S</span>&isin;Ob <span class="categorie">C</span> if it is a product of (X,f) and (Y,g) in the category <span class="categorie">C/<span class="object">S</span></span>      
     of <span class="object">S</span>-objects. Also called pullback:
    &quot;parallel translation&quot;.
    Pullbacks are the limits of a three-object category with 
    f:X→S, g:Y→S as non-identity morphisms. They visualize as commutative
    squares with diagonal.
  </dd>  

  <dt id="equalizer">equalizer &le; limit</dt>
  <dd>
    the map e∈Mor(E,X), with E∈Ob <span class="categorie">C</span>, is an    
    equalizer of the maps f,g∈Mor(X,Y) :⇔     
    <div style="text-align: center">
 f∘e         
      = g∘e<sub><br>   
      </sub><sub></sub>&and; <big>(</big>∀E'∈Ob <span class="categorie">C</span> ∀e'<sub></sub>∈Mor<sub><span class="categorie">C</span></sub>(E',X)    
 f∘e'         
      = g∘e' &rArr;<br />       
 ∃!&eta;∈Mor<sub><span class="categorie">C</span></sub>(E',E) e'         
      = e∘&eta; <big>)</big>        
    </div>
    e is a unique monomorphism (up to isomorphism). f.ex. The kernel of f is the
    equalizer of f and 0. Equalizers are the limits of the identity functor
    from a two-object category with two parallel morphisms in between.
   </dd>   
   
  <dt id="coequalizer">coequalizer &le; colimit</dt>
  <dd>
    the map c∈Mor(Y,C), with C∈Ob <span class="categorie">C</span>, is a coequalizer of the  
    maps f,g∈Mor(X,Y) :⇔     
    <div style="text-align: center">
 c∘f         
      = c∘g<sub><br>  
      </sub>&and; <big>(</big>∀C'∈Ob <span class="categorie">C</span>  ∀c'∈Mor<sub><span class="categorie">C</span></sub>(Y,C')   
 c'∘f         
      = c'∘g &rArr;<br />       
 ∃!&gamma;∈Mor<sub><span class="categorie">C</span></sub>(C,C') c'         
      = &gamma;∘c <big>)</big>        
    </div>
    c is a unique epimorphism (up to isomorphism). f.ex. The cokernel of f is the  
    coequalizer of f and 0.    
   </dd>   
   
</dl>
<p>As terminal or initial objects, products and coproducts are uniquely  
determined up to a unique isomorphism. Even more so as they are special cases of 
limits and colimits.</p>
<h2 id="limits">Limits and Colimits</h2> 
<dl class="def">
  Let <span class="categorie">C</span>, <span class="categorie">J</span> be    
  categories.
  <dt id="limit">limit</dt>
  <!-- generalizes inverse limits and products -->
  <dd><img class="annotatingDiagram" src="diagram/commutative/limit2.jpg" width="231" height="155"> 
    L∈Ob <span class="categorie">C</span>, together with φ<sub class="objet">X</sub>∈Mor<sub><span class="categorie">C</span></sub>(L,F(X))    
    for each X∈Ob <span class="categorie">J</span>, is a <dfn>cone</dfn> of the covariant    
    functor <span class="foncteur">F</span>:<span class="categorie">J</span>→<span class="categorie">C</span>&nbsp;    
    :⇔
    <div style="text-align: center">
      ∀f∈Mor<sub><span class="categorie">J</span></sub>(<span class="objet">X</span>,<span class="objet">Y</span>)   
      F(f)<sub></sub>∘φ<sub class="objet">X</sub>=φ<sub class="objet">Y</sub><br />
    </div>
 
    A limit of the covariant functor <span class="foncteur">F</span>:<span class="categorie">J</span>→<span class="categorie">C</span>
    is a universal cone
    (<span class="objet">L</span>,<span class="seriesOperator">(</span>φ<sub class="objet">X</sub><span class="seriesOperator">)</span><sub>X∈Ob   
      <span class="categorie">J</span></sub>), i.e. 
      the morphisms of any cone factor through <span class="objet">L</span> with the unique factorization u, i.e.
    <div style="text-align: center">
      ∀(N,<span class="seriesOperator">(</span>ψ<sub class="objet">X</sub><span class="seriesOperator">)</span><sub>X∈Ob   
      <span class="categorie">J</span></sub>) cone of <span class="foncteur">F</span>
      ∃!u∈Mor<sub><span class="categorie">C</span></sub>(N,L) ∀X∈Ob <span class="categorie">J</span>   
      φ<sub class="objet">X</sub>∘u = ψ<sub class="objet">X</sub> 
    </div>
    Write: L = lim <span class="foncteur">F</span>   
    = lim<sub>←</sub> F "glue together related objects by morphisms". 
    Limits relativate products to the situation where the morphisms commute
    over the F(f).
    Limits are sometimes also known as inverse limit or projective
    limit. Examples of limits include products, terminal objects, equalizers,
    kernels, pullbacks.
    </dd>   
  <dt id="colmit">colimit</dt>
  <!-- generalizes direct limits -->
  <dd><img class="annotatingDiagram" src="diagram/commutative/colimit2.jpg" width="231" height="155"> 
    <!-- the arrow F(f) in the diagram has the wrong direction -->
    L∈Ob <span class="categorie">C</span>, together with a family φ<sub class="objet">X</sub>∈Mor<sub><span class="categorie">C</span></sub>(F(X),L)   
    for X∈Ob <span class="categorie">J</span>, is a <dfn>co-cone</dfn> of the covariant   
    functor <span class="foncteur">F</span>:<span class="categorie">J</span>→<span class="categorie">C</span>&nbsp;   
    :⇔
    <div style="text-align: center">
      ∀f∈Mor<sub><span class="categorie">J</span></sub>(<span class="objet">X</span>,<span class="objet">Y</span>)   
      φ<sub>X</sub>∘F(f)=φ<sub>Y</sub>
    </div>
    A colimit of the covariant  functor <span class="foncteur">F</span>:<span class="categorie">J</span>→<span class="categorie">C</span> is a universal
    co-cone (L,φ<sub class="objet">X</sub>), i.e. 
    <div style="text-align: center">
      ∀(N,<span class="seriesOperator">(</span>ψ<sub class="objet">X</sub><span class="seriesOperator">)</span><sub>X∈Ob   
      <span class="categorie">J</span></sub>) co-cone of <span class="foncteur">F</span>
      ∃!u∈Mor<sub><span class="categorie">C</span></sub>(L,N) ∀X∈Ob <span class="categorie">J</span>   
      u∘φ<sub class="objet">X</sub> = ψ<sub class="objet">X</sub>   
    </div>
    Write: L = colim <span class="foncteur">F = lim<sub>→</sub> F</span>
    <br/>
    <span class="foncteur">F</span>:<span class="categorie">J</span>→<span class="categorie">C</span> has a colimit &hArr;
    &forall;N∈Ob <span class="categorie">C</span> the covariant functor X↦Mor<sub><span class="categorie">C</span></sub>(<span class="foncteur">F</span>(<span class="objet">X</span>),<span class="objet">N</span>)
     in <span class="categorie">J</span><sup>op</sup> has a limit.
    <div style="text-align: center">
     &rArr; Mor<sub><span class="categorie">C</span></sub>(colim <span class="foncteur">F</span>,<span class="objet">N</span>)
     = lim Mor<sub><span class="categorie">C</span></sub>(<span class="foncteur">F</span>(·),<span class="objet">N</span>)
    </div>
    "Colimits are for glueing together mathematical objects."
    Colimits are sometimes also known as direct limit or inductive limit.
    Examples of colimits include coproducts, inital objects, coequalizers,
    cokernels, pushouts.
    </dd> 
</dl>
<p> Limits and colimits are uniquely  
determined up to a unique isomorphism, because they are inital (resp. terminal) 
objects in the category of cones of <span class="foncteur">F</span>.</p>

</body>

</html>
