<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-gb">
<meta name="author" content="Andre Platzer">
<meta name="copyright" content="© 2002 André Platzer">
<meta name="classification" content="Science/Mathematics/Category/Basics">
<title>Category theory</title>
<link rel="stylesheet" href="../../../../stylist.css" type="text/css" title="layout">
</head>

<body>

<h2>Contents</h2>
<ul>
  <li><a href="#categoriesAndFunctors">Categories and Functors</a>
  <li><a href="#universalElements">Universal Elements</a></li>
  <li><a href="#products">Product and Coproduct</a></li>
</ul>
<h2 id="categoriesAndFunctors">Categories and Functors</h2>
<p>&quot;general abstract nonsense&quot;, &quot;functors leave complexes 
complex&quot;</p>
<dl class="def">
  <dt id="category">category</dt>
  <dd>A category <span class="categorie">C</span> consists of a family Ob <span class="categorie">C</span> 
    of <i>objects</i>, and for each <span class="objet">A</span>,<span class="objet">B</span>∈Ob 
    <span class="categorie">C</span> a set Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>) 
    of <i>morphisms</i> between <span class="objet">A</span> and <span class="objet">B</span> 
    such that
    <table>
      <tr>
        <th>(r)</th>
        <td>∀<span class="objet">A</span>∈Ob <span class="categorie">C</span> 
          ∃id<span class="objet"><sub>A</sub></span>∈Mor<sub><span class="categorie">C</span></sub>(<span class="objet">A</span>,<span class="objet">A</span>)</td>
        <td>&quot;reflexive, identity&quot;</td>
      </tr>
      <tr>
        <th>(t)</th>
        <td>∀<span class="objet">A</span>,<span class="objet">B</span>,<span class="objet">C</span>∈Ob 
          <span class="categorie">C</span> ∃∘:Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">B</span>,<span class="objet">C</span>)×Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)→Mor<span class="categorie"><sub>C</sub></span>(A,<span class="objet">C</span>) 
          with</td>
        <td>&quot;transitive, composition&quot;</td>
      </tr>
      <tr>
        <th rowspan="2">(n)</th>
        <td>∀<span class="objet">A</span>,<span class="objet">B</span>∈Ob <span class="categorie">C</span> 
          ∀g∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>) 
          g∘id<span class="objet"><sub>A</sub></span> = g</td>
        <td rowspan="2">&quot;neutral&quot;</td>
      </tr>
      <tr>
        <td>∀<span class="objet">A</span>,<span class="objet">B</span>∈Ob <span class="categorie">C</span> 
          ∀f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">B</span>,A) 
          id<span class="objet"><sub>A</sub></span>∘f = f</td>
      </tr>
      <tr>
        <th>(a)</th>
        <td>∀<span class="objet">A</span>,<span class="objet">B</span>,<span class="objet">C</span>,<span class="objet">D</span>∈Ob 
          <span class="categorie">C</span> ∀f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)∀g∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">B</span>,<span class="objet">C</span>)∀h∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">C</span>,<span class="objet">D</span>) 
          (h∘g)∘f = h∘(g∘f)</td>
        <td>&quot;associative&quot;</td>
      </tr>
    </table>
    We usually assume that Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>) 
    ∩ Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">C</span>,<span class="objet">D</span>) 
    = ∅ unless <span class="objet">A</span>=<span class="objet">C</span> ∧ 
    B=<span class="objet">D</span>.<br>
    Write: f:<span class="objet">A</span>→<span class="objet">B</span> for 
    f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)
    <p><span style="float: left; font-size: 200%">☡</span> Beware: Unlike Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>), 
    Ob <span class="categorie">C</span> does not need to be a set of objects, 
    but only a class of objects. Nevertheless we formally write ∈,⊆ etc.</p>
  </dd>
  <dt id="functor">covariant<br>
    functor</dt>
  <dd>A covariant functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D</span> 
    between two categories <span class="categorie">C</span> and <span class="categorie">D</span> 
    consists of a map <span class="foncteur">F</span>:Ob <span class="categorie">C</span>→Ob 
    <span class="categorie">D</span> and for each <span class="objet">A</span>,<span class="objet">B</span>∈Ob 
    <span class="categorie">C</span> a map <span class="foncteur">F</span>:Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)→Mor<span class="categorie"><sub>D</sub></span>(<span class="foncteur">F</span>(<span class="objet">A</span>),<span class="foncteur">F</span>(<span class="objet">B</span>)) 
    that satisfies the following conditions
    <table>
      <tr>
        <th>(1)</th>
        <td>∀<span class="objet">A</span>∈Ob <span class="categorie">C</span> 
          <span class="foncteur">F</span>(id<sub class="objet">A</sub>) = id<sub><span class="foncteur">F</span>(<span class="objet">A</span>)</sub></td>
        <td>&quot;unit&quot;</td>
      </tr>
      <tr>
        <th>(m)</th>
        <td>∀f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)∀g∈Mor<span class="categorie"><sub>C</sub></span>(B,C) 
          <span class="foncteur">F</span>(g∘f) = <span class="foncteur">F</span>(g) 
          ∘ <span class="foncteur">F</span>(f)</td>
        <td>&quot;morph&quot;</td>
      </tr>
    </table>
    <p><span style="float: left; font-size: 200%">☡</span> Beware: <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D</span> 
    is not a map, since <span class="categorie">C</span>,<span class="categorie">D</span> 
    are no sets (they are categories) and even Ob <span class="categorie">C</span>,Ob 
    <span class="categorie">D</span> need not be sets.</p>
  </dd>
  <dt>contra-<br>
    variant<br>
    functor</dt>
  <dd>A contravariant functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D</span> 
    between two categories <span class="categorie">C</span> and <span class="categorie">D</span> 
    consists of a map <span class="foncteur">F</span>:Ob <span class="categorie">C</span>→Ob 
    <span class="categorie">D</span> and for each <span class="objet">A</span>,<span class="objet">B</span>∈Ob 
    <span class="categorie">C</span> a map <span class="foncteur">F</span>:Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)→Mor<span class="categorie"><sub>D</sub></span>(<span class="foncteur">F</span>(<span class="objet">B</span>),<span class="foncteur">F</span>(<span class="objet">A</span>)) 
    that satisfies the following conditions
    <table>
      <tr>
        <th>(1)</th>
        <td>∀<span class="objet">A</span>∈Ob <span class="categorie">C</span> 
          <span class="foncteur">F</span>(id<span class="objet"><sub>A</sub></span>) 
          = id<sub><span class="foncteur">F</span>(</sub><span class="objet"><sub>A</sub></span><sub>)</sub></td>
        <td>&quot;unit&quot;</td>
      </tr>
      <tr>
        <th>(m')</th>
        <td>∀f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>)∀g∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">B</span>,<span class="objet">C</span>) 
          <span class="foncteur">F</span>(g∘f) = <span class="foncteur">F</span>(f) 
          ∘ <span class="foncteur">F</span>(g)</td>
        <td>&quot;contra-morph&quot;</td>
      </tr>
    </table>
    A contravariant functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D</span> 
    is a covariant functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D°</span> 
    (or <span class="foncteur">F</span>:<span class="categorie">C</span><span class="categorie">°</span>→<span class="categorie">D</span>).</dd>
  <dt id="naturalTransformation">natural<br>
    trans-<br>
    formation</dt>
  <dd><img class="annotatingDiagram" src="diagram/commutative/naturalTransformation.jpg" width="221" height="128"> 
    A natural transformation (or morphism of functors) <span class="transformationNaturelle">α</span>:<span class="foncteur">F</span>→<span class="foncteur">G</span> 
    between the functors <span class="foncteur">F</span>,<span class="foncteur">G</span>:<span class="categorie">C</span>→<span class="categorie">D</span> 
    is a family <span class="seriesOperator">(</span><span class="transformationNaturelle">α</span><span class="objet"><sub>C</sub></span>∈Mor<span class="categorie"><sub>D</sub></span>(<span class="foncteur">F</span>(<span class="objet">C</span>),<span class="foncteur">G</span>(<span class="objet">C</span>))<span class="seriesOperator">)</span><span class="objet"><sub>C</sub></span><sub>∈Ob 
    <span class="categorie">C</span></sub> of morphisms such that
    <div>
      ∀f∈Mor<sub><span class="categorie">C</span></sub>(<span class="objet">C</span>,<span class="objet">C</span>') 
      <span class="foncteur">G</span>(f)∘<span class="transformationNaturelle">α</span><span class="objet"><sub>C</sub></span> 
      = <span class="transformationNaturelle">α</span><span class="objet"><sub>C'</sub></span>∘<span class="foncteur">F</span>(f)
    </div>
    <!-- @todo add the commutative diagram -->
    The functors <span class="categorie">C</span>→<span class="categorie">D</span> 
    form a category with natural transformations being the morphisms.<br>
    Remark: an isomorphism of functors is just a family of isomorphisms <span class="seriesOperator">(</span><span class="transformationNaturelle">α</span><span class="objet"><sub>C</sub></span>∈Iso<span class="categorie"><sub>D</sub></span>(<span class="foncteur">F</span>(<span class="objet">C</span>),<span class="foncteur">G</span>(<span class="objet">C</span>))<span class="seriesOperator"></span><span class="seriesOperator">)</span><span class="objet"><sub>C</sub></span><sub>∈Ob 
    <span class="categorie">C</span></sub> with the above property (⇒ 
    especially <span class="foncteur">F</span>(<span class="objet">C</span>)≅<span class="foncteur">G</span>(<span class="objet">C</span>) 
    ∧ <span class="foncteur">G</span>(f) = <span class="transformationNaturelle">α</span><span class="objet"><sub>C'</sub></span>∘<span class="foncteur">F</span>(f)∘<span class="transformationNaturelle">α</span><span class="objet"><sub>C</sub></span><sup>-1</sup>).</dd>
</dl>
<p>The elements of the monoid Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">A</span>) 
are called <dfn>endomorphisms</dfn> of A. The elements of Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">B</span>) 
that have an inverse in Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">B</span>,<span class="objet">A</span>) 
are called <dfn>isomorphisms</dfn>. The elements of the group of isomorphisms in 
Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">A</span>) 
are called <dfn>automorphisms</dfn>.</p>
<table width="100%" class="def">
  <tr>
    <td colspan="3">Let f∈Mor<span class="categorie"><sub>C</sub></span>(<span class="objet">A</span>,<span class="objet">A'</span>) 
      be a morphism.</td>
  </tr>
  <tr>
    <td class="defTerm" id="monomorphism">monomorphism</td>
    <td>∀<span class="objet">B</span>∈Ob <span class="categorie">C</span> <span class="foncteur">m<sub class="objet">B</sub></span>(f) 
      injective</td>
    <td>&quot;f is left cancelable&quot;</td>
  </tr>
  <tr>
    <td></td>
    <td>⇔ f injective</td>
    <td>(if <span class="categorie">C</span>=<span class="categorie">Ens</span> 
      )</td>
  </tr>
  <tr>
    <td class="defTerm" id="epimorphism">epimorphism</td>
    <td>∀<span class="objet">B</span>∈Ob <span class="categorie">C</span> <span class="foncteur">m<sup class="objet">B</sup></span>(f) 
      injective</td>
    <td>&quot;f is right cancelable&quot;</td>
  </tr>
  <tr>
    <td></td>
    <td>⇔ f surjective</td>
    <td>(if <span class="categorie">C</span>=<span class="categorie">Ens</span> 
      )</td>
  </tr>
</table>
<dl class="def">
  <dt id="additive">additive</dt>
  <dd>A category <span class="categorie">C</span> is additive, if
    <table>
      <tr>
        <th>()</th>
        <td>∀<span class="objet">A</span>,<span class="objet">B</span>∈Ob <span class="categorie">C</span> 
          Hom<sub><span class="categorie">C</span></sub>(<span class="objet">A</span>,<span class="objet">B</span>) 
          := Mor<sub><span class="categorie">C</span></sub>(<span class="objet">A</span>,<span class="objet">B</span>) 
          is an Abelian(<a href="../../doc-files/AlgebraicStructures.html#commutativeMagmaHom">!</a>) 
          group</td>
        <td></td>
      </tr>
      <tr>
        <th>(d)</th>
        <td>∘ is distributive over +, i.e.
          <ul>
            <li>∀A,B,C∈Ob <span class="categorie">C</span> ∀f∈Hom<span class="categorie"><sub>C</sub></span>(B,C) 
              ∀g,h∈Hom<span class="categorie"><sub>C</sub></span>(A,B) f∘(g+h) 
              = (f∘g) + (f∘h)</li>
            <li>∀A,B,C∈Ob <span class="categorie">C</span> ∀f,g∈Hom<span class="categorie"><sub>C</sub></span>(B,C) 
              ∀h∈Hom<sub><span class="categorie">C</span></sub>(A,B) (f+g)∘h 
              = (f∘h) + (g∘h)</li>
          </ul>
        </td>
        <td>&quot;distributive&quot;</td>
      </tr>
    </table>
  </dd>
  <dt>additive</dt>
  <dd>A functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">D</span> 
    between two additive categories <span class="categorie">C</span> and <span class="categorie">D</span> 
    is additive, if
    <div>
      ∀<span class="objet">A</span>,<span class="objet">B</span>∈Ob <span class="categorie">C</span> 
      <span class="foncteur">F</span>:Hom<sub><span class="categorie">C</span></sub>(<span class="objet">A</span>,<span class="objet">B</span>)<span class="categorie"></span>→Hom<span class="categorie"><sub>D</sub></span>(<span class="foncteur">F</span>(<span class="objet">A</span>),<span class="foncteur">F</span>(<span class="objet">B</span>)) 
      homomorphism of groups
    </div>
    ⇒ ∀<span class="foncteur">G</span>≅<span class="foncteur">F</span> <span class="foncteur">G</span> 
    is additive</dd>
</dl>
<h3>Important Examples</h3>
<ol>
  <li id="opposite">
    <p>For every category <span class="categorie">C</span>, there is the <dfn>opposite</dfn> 
    (dual) category <span class="categorie">C°</span> obtained by &quot;turning 
    the arrows around&quot;, per Ob <span class="categorie">C°</span> := Ob <span class="categorie">C</span>, 
    and Mor<span class="categorie"><sub>C°</sub></span>(A,B) := Mor<span class="categorie"><sub>C</sub></span>(B,A) 
    whereas the identity morphisms are the same, and the composition is f∘<span class="categorie"><sub>C°</sub></span>g 
    := g∘<span class="categorie"><sub>C</sub></span>f.<br>
    <b>Duality Principle</b>: Any theorem holding for a category <span class="categorie">C</span> 
    also holds <i>(in <span class="categorie">C°</span>)</i> with <em>all</em> 
    arrows reversed.</p>
  </li>
  <li>
    <p>Categories together with functors form a category.</p>
  </li>
  <li>
    <p>Additive categories form a category together with additive functors.</p>
  </li>
  <li>
    <p>Functors of a fixed category together with their natural transformations 
    form a category.</p>
  </li>
  <li id="hom-functor">
    <p>Let <span class="categorie">C</span> be a category. For each X∈Ob <span class="categorie">C</span> 
    there are two functors</p>
    <ul>
      <li>covariant hom-functor
        <table>
          <tr>
            <td class="nameOfMap" rowspan="3"><span class="foncteur">m<sub>X</sub></span>:=Mor<span class="categorie"><sub>C</sub></span>(X,·):</td>
            <td class="leftOfMap"><span class="categorie">C</span></td>
            <td class="arrowOfMap">→</td>
            <td class="rightOfMap"><span class="categorie">Ens</span></td>
          </tr>
          <tr>
            <td class="leftOfMap"><span class="objet">Y</span></td>
            <td class="arrowOfMap">↦</td>
            <td class="rightOfMap">Y<sub>∗</sub>:=Mor<span class="categorie"><sub>C</sub></span>(X,Y)</td>
          </tr>
          <tr>
            <td class="leftOfMap">(f∈Mor<span class="categorie"><sub>C</sub></span>(Y,Z))</td>
            <td class="arrowOfMap">↦</td>
            <td class="rightOfMap"><big>(</big>Mor<span class="categorie"><sub>C</sub></span>(X,Y)→Mor<span class="categorie"><sub>C</sub></span>(X,Z); 
              g↦f∘g<big>)</big></td>
          </tr>
        </table>
      </li>
      <li>contravariant hom-functor<br>
        <table>
          <tr>
            <td class="nameOfMap" rowspan="3"><span class="foncteur">m<sup>X</sup></span>:=Mor<span class="categorie"><sub>C</sub></span>(·,X):</td>
            <td class="leftOfMap"><span class="categorie">C</span></td>
            <td class="arrowOfMap">→</td>
            <td class="rightOfMap"><span class="categorie">Ens</span></td>
          </tr>
          <tr>
            <td class="leftOfMap"><span class="objet">Y</span></td>
            <td class="arrowOfMap">↦</td>
            <td class="rightOfMap">Y<sup>∗</sup>:=Mor<span class="categorie"><sub>C</sub></span>(Y,X)</td>
          </tr>
          <tr>
            <td class="leftOfMap">(f∈Mor<span class="categorie"><sub>C</sub></span>(Y,Z))</td>
            <td class="arrowOfMap">↦</td>
            <td class="rightOfMap"><big>(</big>Mor<span class="categorie"><sub>C</sub></span>(Z,X)→Mor<span class="categorie"><sub>C</sub></span>(Y,X); 
              g↦g∘f<big>)</big></td>
          </tr>
        </table>
      </li>
    </ul>
    <p>They result from currying ∘. The properties of being a functor 
    coincides with the properties of morphisms (n) and (a), here. <span class="foncteur">m<sup>X</sup></span> 
    is the opposite of <span class="foncteur">m<sub>X</sub></span>. If <span class="categorie">C</span> 
    is additive we write Hom<span class="categorie"><sub>C</sub></span>(X,·):=<span class="foncteur">h<sub>X</sub></span>:=<span class="foncteur">m<sub>X</sub></span>, 
    and Hom<span class="categorie"><sub>C</sub></span>(·,X):=<span class="foncteur">h<sup>X</sup></span>:=<span class="foncteur">m<sup>X</sup></span> 
    for these functors in <span class="categorie">C</span>→<span class="categorie">Ab</span>, 
    which are additive, then. The properties of being additive coincides with 
    (d).</p>
  </li>
</ol>
<!--@todo check names of Y<sub>∗</sub>, and Y<sup>∗</sup> .-->
<h3>Additional definitions....</h3>
<dl>
  <dt id="Yoneda">Yoneda-Lemma</dt>
  <dd>Let <span class="categorie">F</span> be the category of functors <span class="categorie">C</span>→<span class="categorie">Ens</span><br />
    ⇒ ∀A,B∈Ob <span class="categorie">C</span> the following map is 
    bijective<br>
    <table>
      <tr>
        <td class="nameOfMap" rowspan="3">α:</td>
        <td class="leftOfMap">Mor<span class="categorie"><sub>C</sub></span>(A,B)</td>
        <td class="arrowOfMap">→̃</td>
        <td class="rightOfMap">Mor<span class="categorie"><sub>F</sub></span>(<span class="foncteur">m<sub class="objet">B</sub></span>,<span class="foncteur">m<sub class="objet">A</sub></span>)</td>
      </tr>
      <tr>
        <td class="leftOfMap"><span class="transformationNaturelle">τ</span><sub>B</sub>(<span class="morphisme">id<sub>B</sub></span>)</td>
        <td class="arrowOfMap">↤</td>
        <td class="rightOfMap"><span class="transformationNaturelle">τ</span></td>
      </tr>
      <tr>
        <td class="leftOfMap">φ</td>
        <td class="arrowOfMap">↦</td>
        <td class="rightOfMap">
          <table>
            <tr>
              <td class="nameOfMap"><span class="transformationNaturelle">α<sub>φ</sub></span>:</td>
              <td class="leftOfMap"><span class="foncteur">m<sub class="objet">B</sub></span>
              <td class="arrowOfMap">→</td>
              <td class="rightOfMap"><span class="foncteur">m<sub class="objet">A</sub></span></td>
            <tr>
              <td rowspan="2" class="nameOfMap">(<span class="transformationNaturelle">α<sub>φ</sub></span>)<span class="categorie"><sub>C</sub></span>:</td>
              <td class="leftOfMap">Mor<span class="categorie"><sub>C</sub></span>(B,C)
              <td class="arrowOfMap">→</td>
              <td class="rightOfMap">Mor<span class="categorie"><sub>C</sub></span>(A,C)</td>
            </tr>
            <tr>
              <td class="leftOfMap">f</td>
              <td class="arrowOfMap">↦</td>
              <td class="rightOfMap">f∘φ</td>
            </tr>
          </table>
        </td>
      </tr>
    </table>
    <p>If <span class="categorie">C</span> is additive and <span class="categorie">F</span> 
    the category of (additive?) functors <span class="categorie">C</span>→<span class="categorie">Ab</span>, 
    then α is an isomorphism of groups.</dd>
</dl>
<dl class="def">
  <dt id="adjoint">adjoint</dt>
  <dd><span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">C'</span> 
    left-adjoint to <span class="foncteur">G</span>:<span class="categorie">C'</span>→<span class="categorie">C</span> 
    (and <span class="foncteur">G</span> right-adjoint to <span class="foncteur">F</span>) 
    :⇔
    <div>
      <span class="foncteur">m<sub><span class="foncteur">F</span></sub></span> 
      := Mor<span class="categorie"><sub>C'</sub></span>(<span class="foncteur">F</span>(·),·) 
      ≅ Mor<span class="categorie"><sub>C</sub></span>(·,<span class="foncteur">G</span>(·)) 
      =: <span class="foncteur">m<sup><span class="foncteur">G</span></sup></span> 
      in <span class="categorie">C</span><span class="categorie">°</span>×<span class="categorie">C'</span>→<span class="categorie">Ens</span>
    </div>
  </dd>
  <dt id="equivalentCategories">equivalent<br>
    categories</dt>
  <dd><span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">C'</span> 
    is an equivalence of categories :⇔
    <div>
      ∃<span class="foncteur">G</span>:<span class="categorie">C'</span>→<span class="categorie">C</span> 
      with <span class="foncteur">F</span>∘<span class="foncteur">G</span>≅id<sub class="categorie">C'</sub> 
      ∧ <span class="foncteur">G</span>∘<span class="foncteur">F</span>≅id<sub class="categorie">C</sub>
    </div>
    <div>
      ⇒ <span class="foncteur">F</span> left-adjoint to <span class="foncteur">G</span> 
      and conversely
    </div>
  </dd>
</dl>
<p>For the following definition, <span class="categorie">A</span> and <span class="categorie">A'</span> 
must be categories that have exact sequences (more precisely: Abelian 
categories).</p>
<dl class="def">
  <dt id="exact">exact</dt>
  <dd><span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span> 
    is exact :⇔ <span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span> 
    is a (covariant) additive functor, and
    <table>
      <tr>
        <td>If</td>
        <td>0</td>
        <td>→</td>
        <td><span class="categorie">A'</span></td>
        <td>→<sup>α</sup></td>
        <td><span class="categorie">A</span></td>
        <td>→<sup>β</sup></td>
        <td><span class="categorie">A''</span></td>
        <td>→</td>
        <td>0</td>
        <td>is an exact sequence in <span class="categorie">A</span></td>
      </tr>
      <tr>
        <td>Then</td>
        <td>0</td>
        <td>→</td>
        <td><span class="foncteur">F</span>(<span class="categorie">A'</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(α)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(β)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A''</span>)</td>
        <td>→</td>
        <td>0</td>
        <td>is an exact sequence in <span class="categorie">A'</span></td>
      </tr>
    </table>
    That the image under <span class="foncteur">F</span> of the sequence (or any 
    complex) is a complex, is always true since <span class="foncteur">F</span> 
    is a functor.</dd>
  <dt id="leftExact">left exact</dt>
  <dd><span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span> 
    is left exact :⇔ <span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span> 
    is a (covariant) additive functor, and
    <table>
      <tr>
        <td>If</td>
        <td>0</td>
        <td>→</td>
        <td><span class="categorie">A'</span></td>
        <td>→<sup>α</sup></td>
        <td><span class="categorie">A</span></td>
        <td>→<sup>β</sup></td>
        <td><span class="categorie">A''</span></td>
        <td>(→</td>
        <td>0)</td>
        <td>is an exact sequence in <span class="categorie">A</span></td>
      </tr>
      <tr>
        <td>Then</td>
        <td>0</td>
        <td>→</td>
        <td><span class="foncteur">F</span>(<span class="categorie">A'</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(α)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(β)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A''</span>)</td>
        <td></td>
        <td></td>
        <td>is an exact sequence in <span class="categorie">A'</span>.</td>
      </tr>
    </table>
  </dd>
  <dt id="leftExact">right exact</dt>
  <dd><span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span> 
    is right exact :⇔ <span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span> 
    is a (covariant) additive functor, and
    <table>
      <tr>
        <td>If</td>
        <td>(0</td>
        <td>→)</td>
        <td><span class="categorie">A'</span></td>
        <td>→<sup>α</sup></td>
        <td><span class="categorie">A</span></td>
        <td>→<sup>β</sup></td>
        <td><span class="categorie">A''</span></td>
        <td>→</td>
        <td>0</td>
        <td>is an exact sequence in <span class="categorie">A</span></td>
      </tr>
      <tr>
        <td>Then</td>
        <td></td>
        <td></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A'</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(α)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A</span>)</td>
        <td>→<sup><span class="foncteur">F</span>(β)</sup></td>
        <td><span class="foncteur">F</span>(<span class="categorie">A''</span>)</td>
        <td>→</td>
        <td>0</td>
        <td>is an exact sequence in <span class="categorie">A'</span>.</td>
      </tr>
    </table>
    <span class="foncteur">F</span>:<span class="categorie">A</span>→<span class="categorie">A'</span> 
    is right exact ⇔ <span class="foncteur">F</span>:<span class="categorie">A°</span>→<span class="categorie">A'°</span> 
    is left exact.</dd>
</dl>
<h2 id="universalElements">Universal Elements</h2>
<p>Let <span class="categorie">C</span> be a category.
<dl class="def">
  <dt id="initial">initial<br>
    object</dt>
  <dd><img class="annotatingDiagram" src="diagram/commutative/initial.jpg" width="102" height="89"> 
    A∈Ob <span class="categorie">C</span> is an initial object :⇔ ∀B∈Ob <span class="categorie">C</span> 
    ∃!φ∈Mor<sub><span class="categorie">C</span></sub>(A,B)<br>
    initial objects are uniquely isomorph, i.e. each two initial objects A,B 
    have a unique isomorphism A→B.</dd>
  <dt id="terminal">terminal<br>
    object</dt>
  <dd><img class="annotatingDiagram" src="diagram/commutative/terminal.jpg" width="128" height="82"> 
    A∈Ob <span class="categorie">C</span> is a terminal object :⇔ ∀B∈Ob <span class="categorie">C</span> 
    ∃!φ∈Mor<sub><span class="categorie">C</span></sub>(B,A) ⇔ A is an 
    initial object in <span class="categorie">C°</span>.<br>
    terminal objects are uniquely isomorph, i.e. each two terminal objects A,B 
    have a unique isomorphism A→B.</dd>
  <dt id="presentable">presentable</dt>
  <dd>a covariant (resp. contravariant) functor <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">Ens</span> 
    is presentable :⇔ ∃A∈Ob <span class="categorie">C</span> <span class="foncteur">F</span>≅<span class="foncteur">m<sub>A</sub></span> 
    (resp. <span class="foncteur">F</span>≅<span class="foncteur">m<sup>A</sup></span>)<br>
    A is called presenting object for <span class="foncteur">F</span>.</dd>
  <dt id="universalElement">universal element</dt>
  <dd>If <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">Ens</span> 
    is a presentable covariant functor with a corresponding isomorphism of 
    functors <span class="transformationNaturelle">α</span>:<span class="foncteur">m<sub>A</sub></span>→<span class="foncteur">F</span>, 
    then u<sub><span class="foncteur">F</span></sub> := <span class="transformationNaturelle">α</span><sub>A</sub>(id<sub>A</sub>) 
    ∈ <span class="foncteur">F</span>(A) is called universal element of <span class="foncteur">F</span> <!-- "das Bild vom Faulpelz" -->.
    <div>
      ⇒ ∀B∈Ob <span class="categorie">C</span> ∀x∈<span class="foncteur">F</span>(B) 
      ∃!f∈Mor<sub class="categorie">C</sub>(A,B)=<span class="foncteur">m<sub>A</sub></span>(B) 
      x = <span class="foncteur">F</span>(f)(u<sub><span class="foncteur">F</span></sub>)
      <ul>
        <li><small>(The converse is also true)</small></li>
        <li>&nbsp;if <span class="categorie">C</span> and <span class="categorie">Ens</span> 
          (then <span class="categorie">Ab</span>) are additive, then (<span class="foncteur">m<sub>A</sub></span>,<span class="foncteur">F</span> 
          are and) the <span class="transformationNaturelle">α</span><sub>B</sub> 
          are isomorphisms of groups.</li>
        <li>More generally, if the <span class="foncteur">F</span> (on 
          morphisms) is a homomorphism of a law + that <span class="transformationNaturelle"></span>∘ 
          is distributive over, then the <span class="transformationNaturelle">α</span><sub>B</sub> 
          are isomorphisms of +.</li>
      </ul>
    </div>
  </dd>
</dl>
Let <span class="foncteur">F</span>:<span class="categorie">C</span>→<span class="categorie">Ens</span> 
be a presentable covariant functor.
<ul>
  <li>presenting objects for <span class="foncteur">F</span> are uniquely 
    isomorph. Precisely: for all isomorphisms of functors <span class="transformationNaturelle">α</span>:<span class="foncteur">m<sub>A</sub></span>→<span class="foncteur">F</span>, 
    <span class="transformationNaturelle">α'</span>:<span class="foncteur">m<sub>A</sub></span><sub>'</sub>→<span class="foncteur">F</span> 
    ∃!φ:A<sub></sub>→A' isomorphism with <span class="transformationNaturelle">α</span>∘α<sub>φ</sub> 
    = <span class="transformationNaturelle">α</span>'. (See <a href="#Yoneda">Yoneda-Lemma</a>).</li>
  <li>an isomorphism of functors <span class="transformationNaturelle">α</span>:<span class="foncteur">m<sub>A</sub></span>→<span class="foncteur">F</span> 
    is uniquely determined by its universal element, i.e. ∀u∈<span class="foncteur">F</span>(A) 
    there is at most one <span class="transformationNaturelle">α</span>:<span class="foncteur">m<sub>A</sub></span>→<span class="foncteur">F</span> 
    with <span class="transformationNaturelle">α</span><sub>A</sub>(id<sub>A</sub>)=u.</li>
</ul>
<h2 id="products">Product and Coproduct</h2>
<dl class="def">
  Let <span class="categorie">C</span> be a category, and I be a set.
  <dt id="product">product</dt>
  <dd><img class="annotatingDiagram" src="diagram/commutative/product.jpg" width="149" height="148"> 
    P∈Ob <span class="categorie">C</span>, with the projectors π<sub>i</sub>∈Mor(P,A<sub>i</sub>) 
    for i∈I, is a product of the objects <span class="seriesOperator">(</span>A<sub>i</sub><span class="seriesOperator">)</span><sub>i∈I</sub>⊆Ob 
    <span class="categorie">C</span> :⇔ <center><big>(</big>∀C∈Ob <span class="categorie">C</span> 
    ∀<span class="seriesOperator">(</span>g<sub>i</sub><sub></sub>∈Mor<sub><span class="categorie">C</span></sub>(C,A<sub>i</sub>)<span class="seriesOperator">)</span><sub>i∈I</sub><br />
    ∃!g∈Mor<sub><span class="categorie">C</span></sub>(C,P) ∀i∈I π<sub>i</sub>∘g 
    = g<sub>i</sub> <big>)</big></center>Write: P = ∏<sub>i∈I</sub>A<sub>i</sub><sub><br>
    </sub>&quot;product is universally attracting&quot;, and it is just a 
    terminal object in a suitable category.</dd>
  <dt id="coproduct">coproduct</dt>
  <dd><img class="annotatingDiagram" src="diagram/commutative/coproduct.jpg" width="176" height="159"> 
    S∈Ob <span class="categorie">C</span>, with the inclusions ι<sub>i</sub>∈Mor(A<sub>i</sub>,S) 
    for i∈I, is a coproduct of the objects <span class="seriesOperator">(</span>A<sub>i</sub><span class="seriesOperator">)</span><sub>i∈I</sub>⊆Ob 
    <span class="categorie">C</span> :⇔ <center><big>(</big>∀C∈Ob <span class="categorie">C</span> 
    ∀<span class="seriesOperator">(</span>g<sub>i</sub><sub></sub>∈Mor<sub><span class="categorie">C</span></sub>(A<sub>i</sub>,C)<span class="seriesOperator">)</span><sub>i∈I</sub><br />
    ∃!g∈Mor<sub><span class="categorie">C</span></sub>(S,C) ∀i∈I g∘ι<sub>i</sub> 
    = g<sub>i</sub> <big>)</big></center>Write: S = ∐<sub>i∈I</sub>A<sub>i</sub> 
    (= ∑<sub>i∈I</sub>A<sub>i</sub>, sometimes ⊕<sub>i∈I</sub>A<sub>i</sub>)<br>
    &quot;coproduct is universally repelling&quot;, and it is just an initial 
    object in&nbsp; a suitable category. A coproduct in <span class="categorie">C</span> 
    is just a product in <span class="categorie">C°</span>.</dd>
</dl>
<p>As terminal or initial objects, products and coproducts are uniquely 
determined up to a unique isomorphism.</p>

</body>

</html>
