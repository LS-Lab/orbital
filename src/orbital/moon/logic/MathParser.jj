/**
 * @(#)MathParser.jj 1.0 2000/09/02 Andre Platzer
 *
 * Copyright (c) 2000 Andre Platzer. All Rights Reserved.
 *
 * This software is the confidential and proprietary information
 * of Andre Platzer. ("Confidential Information"). You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into.
 */

options {
    LOOKAHEAD = 1;
    STATIC = false;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(MathParser)
package orbital.moon.logic;

import orbital.logic.imp.*;
import orbital.logic.imp.Symbol;
import orbital.math.*;
import orbital.math.functional.*;
import orbital.logic.functor.Functor;
import orbital.logic.functor.Notation;
import orbital.logic.functor.Notation.NotationSpecification;

import orbital.logic.trs.Substitutions;
import java.util.*;
import java.lang.reflect.*;
import java.beans.IntrospectionException;

/**
 * This class implements a parser for mathematical expressions.
 * <p>
 * Note that function evaluation expressions can be denoted with rectangular brackets as in
 * "sin[2 + 4/15]". Nevertheless, normal brackets () will work as well.</p>
 * @version 0.9, 2000/09/02
 * @author  Andr&eacute; Platzer
 * @see MathExpressionSyntax#createExpression(String)
 * @see <a href="doc-files/MathParser_grammar.html">Grammar</a>
 * @see #parseExpression()
 */
public class MathParser {
    /**
     * Used to tag types that are yet unknown.
     * @todo get rid of all uses of UNKNOWN by type analysis.
     */
    private static final Type UNKNOWN = Types.INDIVIDUAL;
    
    private static final Values valueFactory = Values.getDefaultInstance();
	
    /**
     * Delegate to the current Syntax implementation that is used for creating Atoms.
     */
    protected static ExpressionBuilder syntax = new MathExpressionSyntax();

    /**
     * Set the current syntax for parsing.
     * @param syntax the expression syntax to use for parsing expressions (formulas).
     */
    public void setSyntax(ExpressionBuilder syntax) {
	this.syntax = syntax;
    }

    /**
     * unary junctors.
     */
    protected static Expression combine(Token optok, Expression a) throws ParseException {
	String op = optok.image;
	if ("+".equals(op))
	    return a;
	return composeWrapper(optok, op, new Expression[] {a});
    }
    /**
     * binary junctors.
     */
    protected static Expression combine(Token optok, Expression a, Expression b) throws ParseException {
	return composeWrapper(optok, optok.image, new Expression[] {a, b});
    }

    // support
    
    /**
     * n-ary predicates or functions.
     * @param result specifies the result type. Object.class for functions, and Boolean.class for predicates.
     * @see ExpressionBuilder#compose(Expression,Expression[])
     */
    protected static Expression apply(Token optok, Expression[] a, Type result) throws ParseException {
    	final String op = optok.image;
	return composeWrapper(optok, new SymbolBase(op, Types.map(Types.typeOf(a), result), new NotationSpecification(a.length)), a);
    }

    /**
     * Wraps calls to {@link ExpressionBuilder#compose(Expression,Expression[])} in an exception handling block.
     * @param optok the token that initiated this operation (used in case of ParseExceptions to define the position).
     */
    private static Expression composeWrapper(Token optok, Expression op, Expression[] arg) throws ParseException {
	if (op == null)
	    throw newParseException("illegal compositor: " + op, optok);
	try {
	    return syntax.compose(op, arg);
    	}
    	catch (orbital.logic.imp.ParseException ex) {throw newParseException(ex.getMessage(), optok, ex);}
    }
    /**
     * Wraps calls to {@link ExpressionBuilder#compose(Expression,Expression[])} in an exception handling block.
     * @param optok the token that initiated this operation (used in case of ParseExceptions to define the position).
     * @see <a href="{@docRoot}/Patterns/Design/Convenience.html">Convenience method</a>
     */
    private static Expression composeWrapper(Token optok, Symbol op, Expression[] arg) throws ParseException {
	if (op == null)
	    throw newParseException("illegal compositor: " + op + " (used for " + optok + ")", optok);
	return composeWrapper(optok, syntax.createAtomic(op), arg);
    }
    /**
     * Wraps calls to {@link ExpressionBuilder#compose(Expression,Expression[])} in an exception handling block.
     * @param optok the token that initiated this operation (used in case of ParseExceptions to define the position).
     * @see <a href="{@docRoot}/Patterns/Design/Convenience.html">Convenience method</a>
     */
    private static Expression composeWrapper(Token optok, String op, Expression[] arg) throws ParseException {
	Functor f = Notation.functorOf(op, new Object[arg.length]);
	try {
	    Symbol symbol = new SymbolBase(op, Types.declaredTypeOf(f), Notation.getNotation(f));
	    if (f == null)
		throw newParseException("unknown compositor: " + op, optok);
	    return composeWrapper(optok, symbol, arg);
	}
	catch (IntrospectionException ex) {
	    throw newParseException("could not inspect registered compositor", optok, ex);
	}
    }

    /**
     * Find the function for a function call.
     * <p>
     * Will lookup known functions in {@link orbital.math.functional.Functions}
     * depending upon the arguments.
     * </p>
     */
    protected static MathFunctor findFunction(Token ftok, Object[] arg) throws ParseException {
	final String f = ftok.image;
	try {
	    switch(arg.length) {
	    case 1: {
		final Field exists = Functions.class.getField(f);
		if (!Function.class.isAssignableFrom(exists.getType()))
		    throw LogicParser.newParseException("Function '" + f + "/" + arg.length + "' not defined as unary", ftok);
		return (Function) exists.get(null);
	    }
	    case 2: {
		final Field exists = Functions.class.getField(f);
		if (!BinaryFunction.class.isAssignableFrom(exists.getType()))
		    throw LogicParser.newParseException("Function '" + f + "/" + arg.length + "' not defined as binary", ftok);
		return (BinaryFunction) exists.get(null);
	    }
	    default:
		throw new IllegalArgumentException("Calling a function '" + f  + "/" + arg.length + "' is not supported. Only 1 or two arguments can be used, yet");
	    }
	} catch(NoSuchFieldException notdefined) {
	    throw LogicParser.newParseException("Function '" + f + "/" + arg.length + "' not defined", ftok);
	} catch(IllegalAccessException ex) {
	    throw (InternalError) new InternalError(ex.getMessage()).initCause(ex);
	} catch(SecurityException ex) {
	    throw (InternalError) new InternalError(ex.getMessage()).initCause(ex);
	}
    }

    /**
     * function application.
     * <p>
     * Will compose the function with its arguments in order to represent the function
     * application parsed now.
     * </p>
     * @note a functor is returned since the function application is not evaluated, but
     *  only <em>parsed</em>.
     *  This method results in a composition of function and arguments instead of
     *  the value of the function at the specified arguments.
     * @todo perhaps weaken to Functor for lambda expressions?
     */
    protected static MathFunctor apply(MathFunctor f, Object[] arg) throws ParseException {
	switch(arg.length) {
	case 1:
	    if (f instanceof Function)
		return Functionals.genericCompose((Function) f, arg[0]);
	    else
		throw new IllegalStateException("Function '" + f + "/" + arg.length + "' not defined as unary");
	case 2: {
	    if (f instanceof BinaryFunction)
		return Functionals.genericCompose((BinaryFunction) f, arg[0], arg[1]);
	    else
		throw new IllegalStateException("Function '" + f + "/" + arg.length + "' not defined as binary");
	}
	default:
	    throw new IllegalArgumentException("Calling a function '" + f  + "/" + arg.length + "' is not supported. Only 1 or two arguments can be used, yet");
	}
    }
    
    /**
     * Create a good parse exception with the specified message for the given token parsed.
     */
    static ParseException newParseException(String message, Token tok, Exception cause) {
	return (ParseException) newParseException(message, tok).initCause(cause);
    }
    static ParseException newParseException(String message, Token tok) {
	final ParseException x = new ParseException(message);
	x.currentToken = tok;
    	return x;
    }
}
PARSER_END(MathParser)

SKIP :
{
    " "
|   "\r"
|   "\t"
|   < EOL: "\n" >
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN :
{
    < EOS: "." >
| <LAMBDA : "\u03bb" | "\\">
}

/**
 * Start to parse an arithmetic formula expression.
 * @internal we require <EOF> to be sure we parsed all, and no syntactic garbage lurks around at the end of the input
 */
Expression parseExpression() :
{Expression expr;}
{
    expr = term() <EOF>
	{ return expr; }
  | <EOF>
	{ return null; }
}

/*TOKEN :
{
    <OPERATOR:("<"|">"|"=="|"<="|">="| "&&"|"||"| "&"|"|"| "+"|"-"|"*"|"/"| "^"|"->"|"<=>")>
|   <UNARY_OPERATOR:("~")>
}*/

// expression parsing methods

Expression term() :
{Expression f;}
{
	f = SumExpression()
{return f;}
}

// junctors

Expression SumExpression() :
{Token tok;Expression a, b;}
{
    a = ProductExpression() ( (tok = "+" | tok = "-") b = ProductExpression() {a = combine(tok, a, b);} )*
{return a;}
}

Expression ProductExpression() :
{Token tok;Expression a, b;}
{
    a = PowerExpression() ( (tok = "*" | tok = "/") b = PowerExpression() {a = combine(tok, a, b);} )*
{return a;}
}

Expression PowerExpression() :
{Token tok;Expression a, b;}
{
    // right associative xfy
     /*
      * right associtivity is expressed using a right-recursive grammar
      * specification. The LOOKAHEAD specification tells JavaCC to look ahead
      * for a "^" token, otherwise the correct match won't be taken. 
      * @todo or tok = "**"
      */
    a = UnaryExpression() (LOOKAHEAD("^") tok = "^" b = PowerExpression() {a = combine(tok, a, b);} )*
{return a;}
}

// unary operators

Expression UnaryExpression() :
{Token tok;Expression v;}
{
    ( tok = "+" | tok = "-" ) v = UnaryExpression() {return combine(tok, v);}
    //TODO: unary x^-1
|   v = value() {return v;}
}

// atomic values

Expression value() :
{Expression f;}
{
( LOOKAHEAD(2)
	f = functionApplication()
|
        f = AtomicTerm()
|	"(" f = term() ")"
)
{return f;}
}


/**
 * Parse an atomic term.
 */
Expression AtomicTerm() :
{Symbol s;}
{
    s = literal()
	{return (Expression) syntax.createAtomic(s);}
}

/* LITERALS (same as LogicParser) */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
  >
|
  < #DECIMAL_LITERAL: (<DIGIT>)+ >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
//      | "." (["0"-"9"])+ (<EXPONENT>)?			// removed due to lambdaAbstraction (\x.2*x)
      | (["0"-"9"])+ (<EXPONENT>)?
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
|   <#DIGIT : ["0"-"9"]>
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT_OR_ALIKE>)* >
|
  < #LETTER:
      [
//       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT_OR_ALIKE:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/**
 * Parse an atomic literal value (atom or number or string).
 */
Symbol literal() :
{Token tok;}
{
    //@todo depending upon number of digits, we could parse optmized <INTEGER_LITERAL>	{return new Integer.Long(Long.parseLong(tok.image));}
    tok = <INTEGER_LITERAL>     	{return new SymbolBase(tok.image, LogicParser.INTEGER_LITERAL_TYPE);}
|   tok = <FLOATING_POINT_LITERAL>	{return new SymbolBase(tok.image, LogicParser.FLOAT_LITERAL_TYPE);}
|   tok = <STRING_LITERAL>		{return new SymbolBase(tok.image, LogicParser.STRING_LITERAL_TYPE);}
|   tok = <IDENTIFIER>			{return new SymbolBase(tok.image, Types.INDIVIDUAL);}
}

/**
 * application alias function call.
 * Will resolve multiple applicable functions by arity and type of the arguments.
 * @note a functor is returned since the function application is not evaluated, but only <em>parsed</em>.
 *  This method results in a composition of function and arguments instead of
 *  the value of the function at the specified arguments.
 * @internal we cannot move the lambdaAbstraction() case into function()
 *  because the return types don't fit.
 */
Expression functionApplication() :
{Token tok;Expression f;Expression[] arg;}
{
    tok = function() arg = Arguments()
	{return apply(tok, arg, UNKNOWN);}
|   f = lambdaAbstraction() arg = Arguments()
        {
	    if (arg.length != 1)
	        throw new ParseException("only unary application of lambda abstractions is supported");
	    //@todo which exact optok token?
	    return composeWrapper(null, f, arg);
	}
}

/**
 * Ordinary function (predefined, or built-in, or ...).
 */
Token function() :
{Token tok;}
{
    tok = <IDENTIFIER>
{return tok;}
}

/**
 * &lambda;-abstraction term.
 * @todo let our surroundings (not us) also support variables/constants bound to &lambda;-abstractions.
 * @note that (\x.2*x) can be parsed as expected because .2 is not a real number but only 0.2
 * @see orbital.logic.trs.Substitutions#lambda
 */
Expression lambdaAbstraction() :
{Token tok, x;Expression t;}
{
    "(" tok = <LAMBDA> x = <IDENTIFIER> "." t = term() ")"
	{return composeWrapper(tok, MathExpressionSyntax.LAMBDA, new Expression[] {syntax.createAtomic(new SymbolBase(x.image, Types.INDIVIDUAL)), t});}
}

Expression[] Arguments() :
{Expression[] s = null;}
{
(
    "(" [ s = Argument_list() ] ")"
|
    "[" [ s = Argument_list() ] "]"
)
{return s;}
}

Expression[] Argument_list() :
{List r = new LinkedList(); Expression x;}
{
    x = term() {r.add(x);} ( "," x = term() {r.add(x);} )*
{return (Expression[])r.toArray(new Expression[0]);}
}
