/**
 * @(#)LogicParser.jj 1.0 2001/01/16 Andre Platzer
 *
 * Copyright (c) 1999-2002 Andre Platzer. All Rights Reserved.
 *
 * This software is the confidential and proprietary information
 * of Andre Platzer. ("Confidential Information"). You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into.
 */

options {
    LOOKAHEAD = 1;
    STATIC = false;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(LogicParser)
package orbital.moon.logic;

import orbital.logic.imp.*;
import orbital.logic.functor.Notation.NotationSpecification;

import java.util.List;
import java.util.LinkedList;
import java.util.Iterator;

/**
 * This class implements a Parser for logic formulas that can be used
 * for every logic  after bound to it. The LogicParser will result in
 * a tree of Expressions (usually Formulas) whose implementation will
 * depend upon the Logic implementation specified.
 * <p>
 * Although this distinction may sometimes sound artificial,
 * we will - for the moment - distinguish three types of syntactic expressions:
 * <ul>
 *   <li>(arithmetic and functional) terms</li>
 *   <li>(logical) formulas</li>
 *   <li>unspecific expressions combining both terms and formulas</li>
 * </ul>
 * </p>
 * <p>
 * This parser can be used by implementations of logic. So there
 * is no need to interface with this parser directly. Instead, it
 * is sufficient to call the {@link ExpressionSyntax#createExpression(String)}
 * implementation of the specific logic.
 * </p>
 * @version 1.0, 2001/01/16
 * @author  Andr&eacute; Platzer
 * @see <a href="doc-files/LogicParser_grammar.html">Grammar</a>
 * @see ExpressionSyntax#createExpression(String)
 * @see #parseFormula()
 * @see #parseFormulas()
 * @todo use a UTF-8 input stream and support the true Unicode
 * characters for forall, exist, and, or, not, ...
 * @todo unite with MathParser! Especially provide arbitrary functions
 * and fixed predicate "=" here
 * @todo should use precedence and associativity information from
 * orbital.logic.imp.Symbol instead of hard wiring parser.
 * @todo (we should be able to use LogicParser to find out the
 * Signature, adapt it such that he can find out new symbols like in
 * ~p(X) the predicate p/1 and object variable X)
 * @xxx "disambiguate" and disallow acception of $p(x) as $p (x) and °p(x) as °p (x) and alike
 * @todo get rid of all this exception wrapping and unwrapping by wrapping the final orbital.logic.imp.ParseException inside an unchecked exception once, and unwrap it once
 * @internal note that all this nested lookahead with a lot of backtracking kills performance.
 */
public class LogicParser {
    static final Type INTEGER_LITERAL_TYPE = Types.type(orbital.math.Integer.class);
    static final Type FLOAT_LITERAL_TYPE = Types.type(orbital.math.Real.class);
    static final Type STRING_LITERAL_TYPE = Types.type(String.class);
    private static final Type BOOLEAN = Types.type(Boolean.class);
	
    /**
     * Delegate to the current syntax implementation that is used for building expressions.
     */
    protected ExpressionSyntax syntax;

    /**
     * Caches the core signature of {@link #syntax}.
     */
    private transient Signature coreSignature;

    /**
     * The accumulated signature already occured in the current scope of the current
     * {@link #parseFormulas(ExpressionSyntax) parsing process}.
     */
    protected Signature scopeSymbolMap;

    /**
     * Set the current syntax for parsing.
     * @param syntax the expression syntax to use for parsing expressions (formulas).
     */
    public void setSyntax(ExpressionSyntax syntax) {
	this.syntax = syntax;
	this.coreSignature = syntax.coreSignature();
    }
    private void reinitSymbolMap() {
	if (syntax == null)
	    throw new IllegalStateException("no syntax has been set, use setSyntax(...)");
	this.scopeSymbolMap = new SignatureBase();
    }

    /**
     * unary junctors.
     */
    protected Expression combine(Token optok, Expression a) throws ParseException {
    	String op = optok.image;
    	if (op.length() == 1)
	    switch (op.charAt(0)) {
	    case '!': /*fall-through*/
	    case '¬': op = "~"; break;
	    default: /*ignore*/
	    }
	return composeWrapper(optok, op, new Expression[] {a});
    }

    /**
     * binary junctors and relations.
     */
    protected Expression combine(Token optok, Expression a, Expression b) throws ParseException {
    	String op = optok.image;
    	// normalize alternative notation
    	switch (op.length()) {
	case 1:
	    switch (op.charAt(0)) {
	    case '\u2227': op = "&"; break;
	    case '\u2228': op = "|"; break;
	    case '\u2260': op = "!="; break;
	    case '\u2264': op = "=<"; break;
	    case '\u2265': op = ">="; break;
	    case '\u2194':
	    case '\u21d4': op = "<->"; break;
	    case '\u2192':
	    case '\u21d2': op = "->"; break;
	    default: /*ignore*/
	    }
	    break;

	case 2:
	    if ("&&".equals(op))
		op = "&";
	    else if ("||".equals(op))
		op = "|";
	    else if ("=>".equals(op))
		op = "->";
	    else if ("\u2228\u0307".equals(op))
		// note that this combining diacritical remark de facto has length 2
		op = "^";
	    break;

	case 3:
	    if ("<=>".equals(op))
		op = "<->";
	    else if ("xor".equals(op))
		op = "^";
	    break;

	default: /*ignore*/
        }
	return composeWrapper(optok, op, new Expression[] {a, b});
    }

    /**
     * quantifiers.
     */
    protected Expression combine(Token optok, Symbol x, Expression a) throws ParseException {
    	String op = optok.image;
    	if (op == null || x == null || a == null)
	    throw new NullPointerException("illegal arguments "+ optok + "," + x + "," + a);
    	// normalize alternative notation
    	if (op.length() == 1)
	    switch (op.charAt(0)) {
	    case '\u2200': op = "°"; break;
	    case '\u2203': op = "?"; break;
	    case '$': op = "free"; break;
	    default: /*ignore*/
	    }
    	if ("all".equals(op))
	    op = "°";
    	else if ("some".equals(op))
	    op = "?";

	if (!x.isVariable())
	    throw new java.lang.AssertionError("parser would only combine quantifiers with variable symbols " + op + " " + x);
	scopeSymbolMap.add(x);
	if ("free".equals(op))
	    // quantifier with pure syntactic function and no semantic aspect at all
	    return a;
	return composeWrapper(optok, op, new Expression[] {syntax.createAtomic(x), a});
    }

    // support
    
    /**
     * n-ary predicates or functions.
     * @param result specifies the result type. Object.class for functions, and Boolean.class for predicates.
     * @see ExpressionBuilder#compose(Expression,Expression[])
     */
    protected Expression apply(Token optok, Expression[] a, Type result) throws ParseException {
    	final String op = optok.image;
	return composeWrapper(optok, new SymbolBase(op, Types.map(Types.typeOf(a), result), new NotationSpecification(a.length)), a);
    }

    /**
     * Wraps calls to {@link ExpressionBuilder#compose(Expression,Expression[])} in an exception handling block.
     * @param optok the token that initiated this operation (used in case of ParseExceptions to define the position).
     */
    private Expression composeWrapper(Token optok, Expression op, Expression[] arg) throws ParseException {
	if (op == null)
	    throw newParseException("illegal compositor: " + op, optok);
	try {
	    return syntax.compose(op, arg);
    	}
    	catch (orbital.logic.imp.ParseException ex) {throw newParseException(ex.getMessage(), optok, ex);}
    }
    /**
     * Wraps calls to {@link ExpressionBuilder#compose(Expression,Expression[])} in an exception handling block.
     * @param optok the token that initiated this operation (used in case of ParseExceptions to define the position).
     * @see <a href="{@docRoot}/Patterns/Design/Convenience.html">Convenience method</a>
     */
    private Expression composeWrapper(Token optok, Symbol op, Expression[] arg) throws ParseException {
	if (op == null)
	    throw newParseException("illegal compositor: " + op + " (used for " + optok + ")", optok);
	return composeWrapper(optok, syntax.createAtomic(op), arg);
    }
    /**
     * Wraps calls to {@link ExpressionBuilder#compose(Expression,Expression[])} in an exception handling block.
     * @param optok the token that initiated this operation (used in case of ParseExceptions to define the position).
     * @see <a href="{@docRoot}/Patterns/Design/Convenience.html">Convenience method</a>
     */
    private Expression composeWrapper(Token optok, String op, Expression[] arg) throws ParseException {
	if (coreSignature.get(op, arg) == null) {
	    System.err.println(">> in signature ");
	    for (Iterator i = coreSignature.iterator(); i.hasNext(); ) {
		Symbol s = (Symbol)i.next();
		System.err.println(s + " " + s.getType());
	    }
	    System.err.println(">> " + op + " applied to " + /*@todo once non-arithmetic are available again use: MathUtilities.format(*/arg + " of type " + Types.typeOf(arg) + " not found");
	}
	return composeWrapper(optok, coreSignature.get(op, arg), arg);
    }

    // symbol declaration handling

    /**
     * declare a new symbol.
     */
    private void declare(Symbol x) throws ParseException {
    	if (x == null)
	    throw new NullPointerException("illegal symbol " + x);
	else if (!x.isVariable())
	    throw new java.lang.AssertionError("parser would only combine quantifiers with variable symbols " + x);
	scopeSymbolMap.add(x);
    }

    /**
     * undeclare a declared symbol at the end of its scope.
     * @todo should we better call undeclare in a finally block?
     */
    private void undeclare(Symbol x) throws ParseException {
    	if (x == null)
	    throw new NullPointerException("illegal symbol " + x);
	else if (!x.isVariable())
	    throw new java.lang.AssertionError("parser would only combine quantifiers with variable symbols " + x);
	// we don't do anything because of the problem with nested occurrences (see below)
	if (false) {
	    boolean changed = scopeSymbolMap.remove(x);
	    //assert changed : "removing a symbol from scope changes the scope";
	    //@xxx (except for nested occurrences like in "all x ((all x p(x)) | q(x))")
	}
    }

    /**
     * @param expectedType the type expected as derived from the context.
     */
    private Symbol symbolFor(String signifier, Type expectedType) {
	// do we already know it is a variable due to a quantifier within whose scope we are?
	for (Iterator i = scopeSymbolMap.iterator(); i.hasNext(); ) {
	    Symbol s = (Symbol) i.next();
	    if (s.getSignifier().equals(signifier))
		return s;
	}
	// else it is treated "the default way"
	return defaultSymbolFor(signifier, expectedType);
    }

    //@todo remove this garbage, because we should always let the user decide what's constant and what's variable, (or at least let him choose the capital/lower convention)
    // either the user can call createExpression(String expr, Signature allowed),
    // or he should explicitly mention any free variables, and all other symbols are either explicitly quantified, or treated as constant
    //@todo rely on FreeDeclarationExpression
    /**
     * only lets _ modify whether it is a variable, not its type.
     */
    private static Symbol defaultSymbolFor(String signifier, Type expectedType) {
    	//@xxx currently we (in addition to $) distinguish between variables and constants according to their first character
    	return signifier.charAt(0) == '_'
	    ? new SymbolBase(signifier, expectedType, null, true)
	    : new SymbolBase(signifier, expectedType, null, false);
    }
    static Symbol defaultSymbolFor(String signifier) {
    	//@xxx currently we (in addition to $) distinguish between variables and constants according to their first character
    	return signifier.charAt(0) == '_'
	    ? new SymbolBase(signifier, SymbolBase.UNIVERSAL_ATOM, null, true)
	    : new SymbolBase(signifier, SymbolBase.BOOLEAN_ATOM, null, false);
    }

    /**
     * Create a good parse exception with the specified message for the given token parsed.
     */
    static ParseException newParseException(String message, Token tok, Exception cause) {
	return (ParseException) newParseException(message, tok).initCause(cause);
    }
    static ParseException newParseException(String message, Token tok) {
	final ParseException x = new ParseException(message);
	x.currentToken = tok;
    	return x;
    }
}
PARSER_END(LogicParser)

SKIP :
{
    " "
|   "\r"
|   "\t"
|   < EOL: "\n" >
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

// operator tokens
TOKEN :
{
  <DECLARE_FREE: "$" | "free">
| <EXISTS: "\u2203" | "?" | "some">
| <FORALL: "\u2200" | "°" | "all">

| <EQUIV: "\u2194" | "\u21d4" | "<->" | "<=>">
| <IMPLY: "\u2192" | "\u21d2" | "->" | "=>">
| <OR: "\u2228" | "|" | "||">
		     //@todo use a better symbol than ^ for xor. Otherwise 4^5 could mean 4 to the power of 5, or 4 xor 5.
| <XOR: "\u2228\u0307" | "xor" | "^">
| <AND: "\u2227" | "&" | "&&">

| <NOT: "¬" | "~" | "!">

| <EQUAL: "=" | "==">
| <UNEQUAL: "\u2260" | "!=">
| <LESS: "<">
| <GREATER: ">">
| <LESS_EQUAL: "\u2264" | "=<">
| <GREATER_EQUAL: "\u2265" | ">=">

| <LAMBDA: "\u03bb" | "\\">
}

/**
 * Start to parse a set of logic formulas with the current syntax.
 * @return the set of formulas parsed,
 *  or an array of length 0 if only the empty set of formulas was found.
 * @see #parseFormula()
 * @todo should we really introduce this method into orbital.logic.imp.Logic/ExpressionSyntax? What would be the delimiters of the individual formulas of a set?
 * @internal we require <EOF> to be sure we parsed all, and no syntactic garbage lurks around at the end of the input
 */
Expression[] parseFormulas() :
{
    reinitSymbolMap();
    List r = new LinkedList();
    Expression expr;
}
{
    expr = expression() {r.add(expr);} ( "," expr = expression() {r.add(expr);} )* <EOF>
	{return (Expression[]) r.toArray(new Expression[0]);}
    | <EOF>
	{ return new Expression[0];}
}


/**
 * Start to parse a logic formula with the current syntax.
 * @see #parseFormulas(ExpressionSyntax)
 * @internal we require <EOF> to be sure we parsed all, and no syntactic garbage lurks around at the end of the input
 */
Expression parseFormula() :
{
    reinitSymbolMap();
    Expression expr;
}
{
    expr = expression() <EOF>
	{ return expr; }
    | <EOF>
	{ return null;/* must be converted later into a denotation of the empty formula */ }
}

// formula parsing methods

Expression expression() :
{Expression f;}
{
    f = FreeDeclarationExpression()
	{return f;}
}

//@todo introduce &jota; x.f operator (by Bertrand Russell)
//@todo introduce Hilbert's &epsilon; x.f operator. If f is true for some value of x, then &epsilon; x.f denotes some such value, otherwise it has an arbitrary value of the same type as x. (embodies the strong Axiom of Choice). @see "Paulson, L.C. The Foundation of a Generic Theorem Prover."

/**
 * free scope "quantifier"
 * A "quantifier" with a purely syntactic function of declaring a variable.
 * @internal introduced an explicit "quantifier" for free variables, resolving all conflicts with variable/constant detection
 * then we can keep track of the accumulated signature during parse and treat everything constant that's not already declared in the signature (and all three binding quantifier will extend the current signature)
 */
Expression FreeDeclarationExpression() :
{Token tok = null;List xs = new LinkedList();Symbol x = null;Expression a;}
{
    (tok = <DECLARE_FREE> x = Variable() {declare(x);xs.add(x);})*
    a = QuantifiedExpression()
	{
	    for (Iterator i = xs.iterator(); i.hasNext(); ) {
		undeclare((Symbol) i.next());
	    }
	    return a;
	}
}

// quantifiers
  
//@todo reduce the binding domain of the quantifiers to the next expression, only, and require "all x (p&q)" instead. Rearrange precedence, such that "all" and "some" bind stronger than &,|,->,<=>
Expression QuantifiedExpression() :
{Token tok = null;List xs = new LinkedList();Symbol x = null;Expression a = null;}
{
    ((tok = <FORALL> | tok = <EXISTS>) x = Variable() {declare(x);xs.add(x);})*
    a = EquivalenceExpression()
	{
	    for (Iterator i = xs.iterator(); i.hasNext(); ) {
		Symbol y = (Symbol) i.next();
		a = combine(tok, y, a);
		undeclare(y);
	    }
	    return a;
	}
}

// junctors

Expression EquivalenceExpression() :
{Token tok;Expression a,b;}
{
    a = ImplicationExpression() ( tok = <EQUIV> b = ImplicationExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

//@todo introduce reverse implication as well
Expression ImplicationExpression() :
{Token tok;Expression a,b;}
{
    a = InclusiveOrExpression() ( tok = <IMPLY> b = InclusiveOrExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

Expression InclusiveOrExpression() :
{Token tok;Expression a,b;}
{
    a = ExclusiveOrExpression() ( tok = <OR> b = ExclusiveOrExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

Expression ExclusiveOrExpression() :
{Token tok;Expression a,b;}
{
    a = AndExpression() ( tok = <XOR> b = AndExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

Expression AndExpression() :
{Token tok;Expression a,b;}
{
    a = UnaryExpression() ( tok = <AND> b = UnaryExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

// unary operators

//@todo how to parse ~all x p(x) where all x p(x) is not a UnaryExpression?
Expression UnaryExpression() :
{Token tok;Expression f;}
{
    tok = <NOT> f = UnaryExpression() {return combine(tok, f);}
    | f = PrimaryExpression()
	{return f;}
}

/**
 * primary formulas that have truth values
 */
Expression PrimaryExpression() :
{Expression a;}
{
    (LOOKAHEAD(Atom())  //@xxx sure? Also note that this is a dramatic performance bottleneck
     a = Atom()
     |	"(" a = expression() ")"
     )
	{return a;}
}

/* IDENTIFIERS */

//@note must be below the keyword tokens like "and", "xor" due to (first) longest-possible match
TOKEN :
{
    <IDENTIFIER : <LETTER> (<LETTER>|<DIGIT_OR_ALIKE>)* >
|   <#LETTER : ["A"-"Z", "a"-"z", "„","”","_"]>
|   <#DIGIT_OR_ALIKE : ["0"-"9"]>
}


/**
 * A formula that is a logical atom.
 * @todo better distinguish between variables and constants (with the possibility for both to appear in	compound expressions for PL2)
 */
Expression Atom() :
{Expression a;String r;Token tok;String s = "";Symbol sym;}
{
    LOOKAHEAD(2)
	a = CompoundFormula()
	{return a;}
    |
	tok = <IDENTIFIER>
	{return (Expression) syntax.createAtomic(symbolFor(tok.image, Types.TRUTH));}
    |
	sym = NumberLiteralValue()
	{return (Expression) syntax.createAtomic(sym);}
}

/**
 * Parse a compound predicate formula for the current logic.
 */
Expression CompoundFormula() :
{Token tok; Expression p; Expression[] arg;}
{
    LOOKAHEAD(2)
    p = EqualityExpression()
        {return p;}
|
    tok = <IDENTIFIER> arg = Arguments()
	{return apply(tok, arg, BOOLEAN);}
|
    p = LambdaAbstractionPredicate() arg = Arguments()
        {
	    if (arg.length != 1)
	        throw new ParseException("only unary application of lambda abstractions is supported. Use currying");
	    //@todo which exact optok token?
	    return composeWrapper(null, p, arg);
	}
}

// relational operators (special predicates on terms)

// Expression EqualityExpression() :
// {Token tok;Expression a,b;}
// {
//     a = RelationalExpression() ( (tok = <EQUAL> | tok = <UNEQUAL>) b = RelationalExpression() {a = combine(tok, a, b);} )*
// 	{return a;}
// }

// Expression RelationalExpression() :
// {Token tok;Expression a,b;}
// {
//     a = term() ( ( tok = <LESS> | tok = <GREATER> | tok = <LESS_EQUAL> | tok = <GREATER_EQUAL> ) b = term() {a = combine(tok, a, b);} )*
// 	{return a;}
// }

//@internal unified EqualityExpression() and RelationalExpression() such that we can replace * by + thereby making it impossible to parse a simple <IDENTIFIER> as such an EqualityExpression()
//  we ensure that we only take this path if EqualityExpression() does not reduce to <IDENTIFIER>
Expression EqualityExpression() :
{Token tok;Expression a,b;}
{
    //@xxx these extra brackets have been introduced temporarily in order to enable parsing (\x. 7>=x)(8) which somehow does not work otherwise (due to a LOOKAHEAD problem)
    "("
	a = term() ( (tok = <EQUAL> | tok = <UNEQUAL> | tok = <LESS> | tok = <GREATER> | tok = <LESS_EQUAL> | tok = <GREATER_EQUAL> ) b = term() {a = combine(tok, a, b);} )+
    ")"
	{return a;}
}

/**
 * &lambda;-abstraction predicate.
 * @see orbital.logic.trs.Substitutions#lambda
 */
Expression LambdaAbstractionPredicate() :
{Token tok; Symbol x;Expression t;}
{
    "(" tok = <LAMBDA> x = VariableDeclaration() "." {declare(x);} t = expression() ")"
{
    undeclare(x);
    return composeWrapper(tok, ClassicalLogic.LAMBDA, new Expression[] {syntax.createAtomic(x), t});
}
}



// true (non-formula) functional term parsing

/**
 * Parse a (non-formula) functional term for the current logic.
 */
Expression term() :
{Expression a;}
{
    a  = PrimaryTerm()
{return a;}
}

Expression PrimaryTerm() :
{Expression a;}
{
    (   LOOKAHEAD(2)
     	a = CompoundTerm()
     |  a = AtomicTerm()
     |	"(" a = expression() /* @xxx better? = term() */")"
     )
	{return a;}
}

/**
 * Parse a compound function term for the current logic.
 */
Expression CompoundTerm() :
{Token tok; Expression f; Expression[] arg;}
{
    tok = <IDENTIFIER> arg = Arguments()
	{return apply(tok, arg, Types.INDIVIDUAL);}
|
    f = LambdaAbstraction() arg = Arguments()
        {
	    if (arg.length != 1)
	        throw new ParseException("only unary application of lambda abstractions is supported");
	    //@todo which exact optok token?
	    return composeWrapper(null, f, arg);
	}
}

/**
 * &lambda;-abstraction term.
 * @todo let our surroundings (not us) also support variables/constants bound to &lambda;-abstractions.
 * @note that (\x.2*x) can be parsed as expected because .2 is not a real number but only 0.2
 * @todo could we define the semantics by Logic.compose("lambda", new Expression[] {x, t}) such that someone can remember the (now fixed) interpretation as a function?
 *  However since substitution can be performed here, on a purely syntactical basis,
 *  it would be enough if the logic (or someone else) could somehow remember definitions for its interpretation.
 * @see orbital.logic.trs.Substitutions#lambda
 */
Expression LambdaAbstraction() :
{Token tok; Symbol x; Expression t;}
{
    "(" tok = <LAMBDA> x = VariableDeclaration() "." {declare(x);} t = term() ")"
{
    undeclare(x);
    return composeWrapper(tok, ClassicalLogic.LAMBDA, new Expression[] {syntax.createAtomic(x), t});
}
}

/**
 * Parse an atomic term (function application, number or string) for the current logic.
 */
Expression AtomicTerm() :
{Symbol s;}
{
    (
        s = LiteralValue()
     |	s = ConstantOrVariable()
    )
	{return (Expression) syntax.createAtomic(s);}
}

// atomic values

/* LITERALS */

TOKEN :
{
    <INTEGER_LITERAL: <DECIMAL_LITERAL> >
|
    <#DECIMAL_LITERAL: (<DIGIT>)+ >
|
    <FLOATING_POINT_LITERAL:
          <DECIMAL_LITERAL> "." (<DECIMAL_LITERAL>)? (<EXPONENT>)?
	| <DECIMAL_LITERAL> (<EXPONENT>)?
    >
|
    <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
    <STRING_LITERAL:
	"\""
			   (   (~["\"","\\","\n","\r"])
			       | ("\\"
				  ( ["n","t","b","r","f","\\","'","\""]
				    | ["0"-"7"] ( ["0"-"7"] )?
				    | ["0"-"3"] ["0"-"7"] ["0"-"7"]
				    )
				  )
			       )*
			   "\""
    >
|   <#DIGIT : ["0"-"9"]>
}


/**
 * atomic term literal value (in the sense of constant primitive type), f.ex. number or string value.
 */
Symbol LiteralValue() :
{Token tok;Symbol s;}
{
    s = NumberLiteralValue()      	{return s;}
|   tok = <STRING_LITERAL> {
	if (tok.image.length() == 3) {
	    if (!((tok.image.charAt(0) == '\'' && tok.image.charAt(2) == '\'')
		  || (tok.image.charAt(0) == '"' && tok.image.charAt(2) == '"')))
	    throw new AssertionError("single character");
	    return new SymbolBase("\"" + tok.image.charAt(1) + "\"", STRING_LITERAL_TYPE);
	}
	return new SymbolBase(tok.image, STRING_LITERAL_TYPE);
    }
}

/**
 * purely numeric atomic term literal value (in the sense of constant primitive type).
 */
Symbol NumberLiteralValue() :
{Token tok;}
{
    tok = <INTEGER_LITERAL>      	{return new SymbolBase(tok.image, INTEGER_LITERAL_TYPE);}
|   tok = <FLOATING_POINT_LITERAL>      {return new SymbolBase(tok.image, FLOAT_LITERAL_TYPE);}
}

/**
 * Parses a constant or a variable atomic term,
 * depending upon known symbols in context.
 * @see #Variable()
 * @todo reject boolean types, since this production only gets called from term(), not expression().
 */
Symbol ConstantOrVariable() :
{String signifier;Token tok;String s = "";}
{
    tok = <IDENTIFIER> {signifier = tok.image;}
    /*      (
	    ( "." tok = <IDENTIFIER>  {signifier += "." + tok.image;} )
	    )*
    */
    {return symbolFor(signifier, Types.INDIVIDUAL);}
}


/**
 * an atomic variable term.
 * @see #ConstantOrVariable()
 */
Symbol Variable() :
{String signifier;Token tok;String s = "";}
{
    tok = <IDENTIFIER> {signifier = tok.image;}
    /*      (
	    ( "." tok = <IDENTIFIER>  {signifier += "." + tok.image;} )
	    )*
    */
    {return new SymbolBase(signifier, Types.INDIVIDUAL, null, true);}
}
/**
 * an atomic variable term with a type declaration.
 */
Symbol VariableDeclaration() :
{String signifier;Token tok;Type type = Types.INDIVIDUAL;}
{
    tok = <IDENTIFIER> {signifier = tok.image;}
    (":" type = TypeConstruct())?
    {return new SymbolBase(signifier, type, null, true);}
}

/**
 * A type construct.
 */
Type TypeConstruct() :
{Token tok;}
{
    tok = <IDENTIFIER> {throw new UnsupportedOperationException("specifying types is not yet supported");}
}

// Parsing Helpers

Expression[] Arguments() :
{Expression[] s = null;}
{
    "(" [ s = Argument_list() ] ")"
	{return s;}
}

Expression[] Argument_list() :
{List r = new LinkedList();Expression x;}
{
    x = term() {r.add(x);} ( "," x = term() {r.add(x);} )*
	{return (Expression[]) r.toArray(new Expression[0]);}
}
