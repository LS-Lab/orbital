/**
 * @(#)LogicParser.java 1.0 2001/01/16 Andre Platzer
 *
 * Copyright (c) 1999-2002 Andre Platzer. All Rights Reserved.
 *
 * This software is the confidential and proprietary information
 * of Andre Platzer. ("Confidential Information"). You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into.
 */

options {
    LOOKAHEAD = 1;
    STATIC = false;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(LogicParser)
package orbital.moon.logic;

import orbital.logic.imp.*;
import orbital.logic.functor.Functor;
import orbital.logic.functor.Functor.Specification;
import orbital.logic.functor.Notation.NotationSpecification;
import orbital.logic.functor.Function;
import orbital.logic.functor.BinaryFunction;
import orbital.logic.functor.Functionals;
import orbital.logic.functor.*;

import orbital.logic.trs.Substitutions;
import java.util.List;
import java.util.LinkedList;
import java.util.Iterator;

/**
 * This class implements a Parser for logic formulas that can be used
 * for every logic  after bound to it. The LogicParser will result in
 * a tree of Expressions (usually Formulas) whose implementation will
 * depend upon the Logic implementation specified.
 * <p>
 * Although this distinction may sometimes sound artificial,
 * we will - for the moment - distinguish three types of syntactic expressions:
 * <ul>
 *   <li>(arithmetic and functional) terms</li>
 *   <li>(logical) formulas</li>
 *   <li>unspecific expressions combining both terms and formulas</li>
 * </ul>
 * </p>
 * @version 1.0, 2001/01/16
 * @author  Andr&eacute; Platzer
 * @see <a href="doc-files/LogicParser_grammar.html">Grammar</a>
 * @see #parseFormula(ExpressionSyntax)
 * @see #parseFormulas(ExpressionSyntax)
 * @todo use a UTF-8 input stream and support the true Unicode
 * characters for forall, exist, and, or, not, ...
 * @todo unite with MathParser! Especially provide arbitrary functions
 * and fixed predicate "=" here
 * @todo should use precedence and associativity information from
 * orbital.logic.imp.Symbol instead of hard wiring parser.
 * @todo (we should be able to use LogicParser to find out the
 * Signature, adapt it such that he can find out new symbols like in
 * ~p(X) the predicate p/1 and object variable X)
 * @xxx "disambiguate" and disallow acception of $p(x) as $p (x) and °p(x) as °p (x) and alike
 * @todo get rid of all this exception wrapping and unwrapping by wrapping the final java.text.ParseException inside an unchecked exception once, and unwrap it once
 * @internal note that all this nested lookahead with a lot of backtracking kills performance.
 */
public class LogicParser {
    private static final Specification INTEGER_LITERAL_TYPE = new Specification(0, orbital.math.Integer.class);
    private static final Specification FLOAT_LITERAL_TYPE = new Specification(0, orbital.math.Real.class);
    private static final Specification STRING_LITERAL_TYPE = new Specification(0, String.class);
	
    /**
     * Delegate to the current Syntax implementation that is used for creating Atoms.
     */
    protected ExpressionSyntax syntax;

    /**
     * The core signature of {@link #syntax}.
     */
    private Signature coreSignature;

    /**
     * The accumulated signature already occured in the current scope of the current
     * {@link #parseFormulas(ExpressionSyntax) parsing process}.
     */
    protected Signature scopeSymbolMap;

    protected void setSyntax(ExpressionSyntax syntax) {
	this.syntax = syntax;
	this.coreSignature = syntax.coreSignature();
	this.scopeSymbolMap = new SignatureBase();
    }

    /**
     * unary junctors.
     */
    protected Expression combine(Token optok, Expression a) throws ParseException {
    	String op = optok.image;
    	if (op.length() == 1)
	    switch (op.charAt(0)) {
	    case '!': /*fall-through*/
	    case '¬': op = "~"; break;
	    default: /*ignore*/
	    }
        try {
	    final Expression[] arg = new Expression[] {a};
	    return syntax.compose(coreSignature.get(op, arg), arg);
    	}
    	catch (java.text.ParseException ex) {throw newParseException(ex.getMessage(), optok);}
    }

    /**
     * binary junctors and relations.
     */
    protected Expression combine(Token optok, Expression a, Expression b) throws ParseException {
    	String op = optok.image;
    	// normalize alternative notation
    	switch (op.length()) {
	case 1:
	    switch (op.charAt(0)) {
	    case '\u2227': op = "&"; break;
	    case '\u2228': op = "|"; break;
	    case '\u2260': op = "!="; break;
	    case '\u2264': op = "=<"; break;
	    case '\u2265': op = ">="; break;
	    case '\u2194':
	    case '\u21d4': op = "<->"; break;
	    case '\u2192':
	    case '\u21d2': op = "->"; break;
	    default: /*ignore*/
	    }
	    break;

	case 2:
	    if ("&&".equals(op))
		op = "&";
	    else if ("||".equals(op))
		op = "|";
	    else if ("=>".equals(op))
		op = "->";
	    else if ("\u2228\u0307".equals(op))
		// note that this combining diacritical remark de facto has length 2
		op = "^";
	    break;

	case 3:
	    if ("<=>".equals(op))
		op = "<->";
	    else if ("xor".equals(op))
		op = "^";
	    break;

	default: /*ignore*/
        }
       	try {
	    final Expression[] arg = new Expression[] {a, b};
	    return syntax.compose(coreSignature.get(op, arg), arg);
    	}
    	catch (java.text.ParseException ex) {throw newParseException(ex.getMessage(), optok);}
    }

    /**
     * quantifiers.
     */
    protected Expression combine(Token optok, Symbol x, Expression a) throws ParseException {
    	String op = optok.image;
    	if (op == null || x == null || a == null)
	    throw new NullPointerException("illegal arguments "+ optok + "," + x + "," + a);
    	// normalize alternative notation
    	if (op.length() == 1)
	    switch (op.charAt(0)) {
	    case '\u2200': op = "°"; break;
	    case '\u2203': op = "?"; break;
	    case '$': op = "free"; break;
	    default: /*ignore*/
	    }
    	if ("all".equals(op))
	    op = "°";
    	else if ("some".equals(op))
	    op = "?";
	try {
            if (!x.isVariable())
            	throw new java.lang.AssertionError("parser would only combine quantifiers with variable symbols " + op + " " + x);
	    scopeSymbolMap.add(x);
	    if ("free".equals(op))
		// quantifier with pure syntactic function
		return a;
	    final Expression[] arg = new Expression[] {syntax.createAtomic(x), a};
	    return syntax.compose(coreSignature.get(op, arg), arg);
    	}
    	catch (java.text.ParseException ex) {throw newParseException(ex.getMessage(), optok);}
    }

    /**
     * n-ary predicates or functions.
     * @param type specifies the result type. Object.class for functions, and Boolean.class for predicates.
     * @see Logic#compose(Symbol,Expression[])
     */
    protected Expression apply(Token optok, Expression[] a, Class type) throws ParseException {
    	final String op = optok.image;
	try {
	    return syntax.compose(new SymbolBase(op, new Specification(a.length, type), new NotationSpecification(a.length)), a);
    	}
    	catch (java.text.ParseException ex) {throw newParseException(ex.getMessage(), optok);}
    }

    /**
     * Wraps calls to {@link Logic#compose(Symbol,Expression[])} in an exception handling block.
     * @param optok the token that initiated this operation (used in case of ParseExceptions to define the position).
     */
    private Expression composeWrapper(Token optok, Symbol op, Expression[] a) throws ParseException {
	try {
	    return syntax.compose(op, a);
    	}
    	catch (java.text.ParseException ex) {throw newParseException(ex.getMessage(), optok);}
    }

    // symbol declaration handling

    /**
     * declare a new symbol.
     */
    private void declare(Symbol x) throws ParseException {
    	if (x == null)
	    throw new NullPointerException("illegal symbol " + x);
	else if (!x.isVariable())
	    throw new java.lang.AssertionError("parser would only combine quantifiers with variable symbols " + x);
	scopeSymbolMap.add(x);
    }

    /**
     * undeclare a declared symbol at the end of its scope.
     * @todo should we better call undeclare in a finally block?
     */
    private void undeclare(Symbol x) throws ParseException {
    	if (x == null)
	    throw new NullPointerException("illegal symbol " + x);
	else if (!x.isVariable())
	    throw new java.lang.AssertionError("parser would only combine quantifiers with variable symbols " + x);
	// we don't do anything because of the problem with nested occurrences (see below)
	if (false) {
	    boolean changed = scopeSymbolMap.remove(x);
	    //assert changed : "removing a symbol from scope changes the scope";
	    //@xxx (except for nested occurrences like in "all x ((all x p(x)) | q(x))")
	}
    }

    private Symbol symbolFor(String signifier) {
	// do we already know it is a variable due to a quantifier within whose scope we are?
	for (Iterator i = scopeSymbolMap.iterator(); i.hasNext(); ) {
	    Symbol s = (Symbol) i.next();
	    if (s.getSignifier().equals(signifier))
		return s;
	}
	// else it is treated as a constant atom
	return defaultSymbolFor(signifier);
    }

    //@todo remove this garbage, because we should always let the user decide what's constant and what's variable, (or at least let him choose the capital/lower convention)
    // either the user can call createExpression(String expr, Signature allowed),
    // or he should explicitly mention any free variables, and all other symbols are either explicitly quantified, or treated as constant
    //@todo ! Perhaps we should introduce an explicit "quantifier" for free variables, resolving all conflicts with variable/constant detection
    // then we can keep track of the accumulated signature during parse and treat everything constant that's not already declared in the signature (and all three binding quantifier will extend the current signature)
    static Symbol defaultSymbolFor(String signifier) {
    	//@xxx currently we (additionally to $) distinguish between variables and constants according to their first character
    	//@see LogicParser#Variable()
    	//return new SymbolBase(signifier, SymbolBase.BOOLEAN_ATOM, null, false);
    	return signifier.charAt(0) == '_'
	    ? new SymbolBase(signifier, SymbolBase.UNIVERSAL_ATOM, null, true)
	    : new SymbolBase(signifier, SymbolBase.BOOLEAN_ATOM, null, false);
    }

    /**
     * Create a good parse exception with the specified message for the given token parsed.
     */
    static ParseException newParseException(String message, Token tok) {
	final ParseException x = new ParseException(message);
	x.currentToken = tok;
    	return x;
    }
}
PARSER_END(LogicParser)

SKIP :
{
    " "
|   "\r"
|   "\t"
|   < EOL: "\n" >
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

// operator tokens
TOKEN :
{
  <DECLARE_FREE: "$" | "free">
| <EXISTS: "\u2203" | "?" | "some">
| <FORALL: "\u2200" | "°" | "all">

| <EQUIV: "\u2194" | "\u21d4" | "<->" | "<=>">
| <IMPLY: "\u2192" | "\u21d2" | "->" | "=>">
| <OR: "\u2228" | "|" | "||">
		     //@todo use a better symbol than ^ for xor. Otherwise 4^5 could mean 4 to the power of 5, or 4 xor 5.
| <XOR: "\u2228\u0307" | "xor" | "^">
| <AND: "\u2227" | "&" | "&&">

| <NOT: "¬" | "~" | "!">

| <EQUAL: "=" | "==">
| <UNEQUAL: "\u2260" | "!=">
| <LESS: "<">
| <GREATER: ">">
| <LESS_EQUAL: "\u2264" | "=<">
| <GREATER_EQUAL: "\u2265" | ">=">

| <LAMBDA: "\u03bb" | "\\">
}

/**
 * Start to parse a set of logic formulas with the given syntax.
 * @return the set of formulas parsed,
 *  or an array of length 0 if only the empty set of formulas was found.
 * @param syntax the expression syntax to use for parsing expressions (formulas).
 * @see #parseFormula(ExpressionSyntax)
 * @todo should we really introduce this method into orbital.logic.imp.Logic/ExpressionSyntax? What would be the delimiters of the individual formulas of a set?
 * @internal we require <EOF> to be sure we parsed all, and no syntactic garbage lurks around at the end of the input
 */
Expression[] parseFormulas(ExpressionSyntax syntax) :
{
    setSyntax(syntax);
    List r = new LinkedList();
    Expression expr;
}
{
    expr = expression() {r.add(expr);} ( "," expr = expression() {r.add(expr);} )* <EOF>
	{return (Expression[]) r.toArray(new Expression[0]);}
    | <EOF>
	{ return new Expression[0];}
}


/**
 * Start to parse a logic formula with the given syntax.
 * @param syntax the expression syntax to use for parsing expressions (formulas).
 * @see #parseFormulas(ExpressionSyntax)
 * @internal we require <EOF> to be sure we parsed all, and no syntactic garbage lurks around at the end of the input
 */
Expression parseFormula(ExpressionSyntax syntax) :
{
    setSyntax(syntax);
    Expression expr;
}
{
    expr = expression() <EOF>
	{ return expr; }
    | <EOF>
	{ return null;/* must be converted later into a denotation of the empty formula */ }
}

// formula parsing methods

Expression expression() :
{Expression f;}
{
    f = FreeDeclarationExpression()
	{return f;}
}

//@todo introduce &jota; x.f operator (by Bertrand Russell)
//@todo introduce Hilbert's &epsilon; x.f operator. If f is true for some value of x, then &epsilon; x.f denotes some such value, otherwise it has an arbitrary value of the same type as x. (embodies the strong Axiom of Choice). @see "Paulson, L.C. The Foundation of a Generic Theorem Prover."

/**
 * free scope "quantifier"
 * A "quantifier" with a purely syntactic function of declaring a variable.
 */
Expression FreeDeclarationExpression() :
{Token tok = null;List xs = new LinkedList();Symbol x = null;Expression a;}
{
    (tok = <DECLARE_FREE> x = Variable() {declare(x);xs.add(x);})*
    a = QuantifiedExpression()
	{
	    for (Iterator i = xs.iterator(); i.hasNext(); ) {
		undeclare((Symbol) i.next());
	    }
	    return a;
	}
}

// quantifiers
  
//@todo reduce the binding domain of the quantifiers to the next expression, only, and require "all x (p&q)" instead. Rearrange precedence, such that "all" and "some" bind stronger than &,|,->,<=>
Expression QuantifiedExpression() :
{Token tok = null;List xs = new LinkedList();Symbol x = null;Expression a = null;}
{
    ((tok = <FORALL> | tok = <EXISTS>) x = Variable() {declare(x);xs.add(x);})*
    a = EquivalenceExpression()
	{
	    for (Iterator i = xs.iterator(); i.hasNext(); ) {
		Symbol y = (Symbol) i.next();
		a = combine(tok, y, a);
		undeclare(y);
	    }
	    return a;
	}
}

// junctors

Expression EquivalenceExpression() :
{Token tok;Expression a,b;}
{
    a = ImplicationExpression() ( tok = <EQUIV> b = ImplicationExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

//@todo introduce reverse implication as well
Expression ImplicationExpression() :
{Token tok;Expression a,b;}
{
    a = InclusiveOrExpression() ( tok = <IMPLY> b = InclusiveOrExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

Expression InclusiveOrExpression() :
{Token tok;Expression a,b;}
{
    a = ExclusiveOrExpression() ( tok = <OR> b = ExclusiveOrExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

Expression ExclusiveOrExpression() :
{Token tok;Expression a,b;}
{
    a = AndExpression() ( tok = <XOR> b = AndExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

Expression AndExpression() :
{Token tok;Expression a,b;}
{
    a = UnaryExpression() ( tok = <AND> b = UnaryExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

// unary operators

//@todo how to parse ~all x p(x) where all x p(x) is not a UnaryExpression?
Expression UnaryExpression() :
{Token tok;Expression f;}
{
    tok = <NOT> f = UnaryExpression() {return combine(tok, f);}
    | f = PrimaryExpression()
	{return f;}
}

/**
 * primary formulas that have truth values
 */
Expression PrimaryExpression() :
{Expression a;}
{
    (LOOKAHEAD(Atom())  //@xxx sure? Also note that this is a dramatic performance bottleneck
     a = Atom()
     |	"(" a = expression() ")"
     )
	{return a;}
}

/* IDENTIFIERS */

//@note must be below the keyword tokens like "and", "xor" due to (first) longest-possible match
TOKEN :
{
    <IDENTIFIER : <LETTER> (<LETTER>|<DIGIT_OR_ALIKE>)* >
|   <#LETTER : ["A"-"Z", "a"-"z", "","","","_"]>
|   <#DIGIT_OR_ALIKE : ["0"-"9"]>
}


/**
 * A formula that is a logical atom.
 * @todo better distinguish between variables and constants (with the possibility for both to appear in	compound expressions for PL2)
 */
Expression Atom() :
{Expression a;String r;Token tok;String s = "";Symbol sym;}
{
    LOOKAHEAD(2)
	a = CompoundFormula()
	{return a;}
    |
	tok = <IDENTIFIER>
	//@todo shouldn't we use symbolFor instead of defaultSymbolFor, in order to allow "free X p&X"?
	{return (Expression) syntax.createAtomic(defaultSymbolFor(tok.image));}
    |
	sym = NumberLiteralValue()
	{return (Expression) syntax.createAtomic(sym);}
}

/**
 * Parse a compound predicate formula for the current logic.
 */
Expression CompoundFormula() :
{Token tok; Expression p; Expression[] arg;}
{
    LOOKAHEAD(2)
    p = EqualityExpression()
        {return p;}
|
    tok = <IDENTIFIER> arg = Arguments()
	{return apply(tok, arg, Boolean.class);}
|
    p = LambdaAbstractionPredicate() arg = Arguments()
        {
	    if (arg.length != 1)
	        throw new ParseException("only unary application of lambda abstractions is supported");
	    //@todo which exact optok token?
	    return composeWrapper(null, ClassicalLogic.APPLY, new Expression[] {p, arg[0]});
	}
}

// relational operators (special predicates on terms)

// Expression EqualityExpression() :
// {Token tok;Expression a,b;}
// {
//     a = RelationalExpression() ( (tok = <EQUAL> | tok = <UNEQUAL>) b = RelationalExpression() {a = combine(tok, a, b);} )*
// 	{return a;}
// }

// Expression RelationalExpression() :
// {Token tok;Expression a,b;}
// {
//     a = term() ( ( tok = <LESS> | tok = <GREATER> | tok = <LESS_EQUAL> | tok = <GREATER_EQUAL> ) b = term() {a = combine(tok, a, b);} )*
// 	{return a;}
// }

//@internal unified EqualityExpression() and RelationalExpression() such that we can replace * by + thereby making it impossible to parse a simple <IDENTIFIER> as such an EqualityExpression()
//  we ensure that we only take this path if EqualityExpression() does not reduce to <IDENTIFIER>
Expression EqualityExpression() :
{Token tok;Expression a,b;}
{
    //@xxx these extra brackets have been introduced temporarily in order to enable parsing (\x. 7>=x)(8) which somehow does not work otherwise (due to a LOOKAHEAD problem)
    "("
	a = term() ( (tok = <EQUAL> | tok = <UNEQUAL> | tok = <LESS> | tok = <GREATER> | tok = <LESS_EQUAL> | tok = <GREATER_EQUAL> ) b = term() {a = combine(tok, a, b);} )+
    ")"
	{return a;}
}

/**
 * &lambda;-abstraction predicate.
 * @see orbital.logic.trs.Substitutions#lambda
 */
Expression LambdaAbstractionPredicate() :
{Token tok; Symbol x;Expression t;}
{
    "(" tok = <LAMBDA> x = Variable() "." {declare(x);} t = expression() ")"
{
    undeclare(x);
    return composeWrapper(tok, ClassicalLogic.LAMBDA, new Expression[] {syntax.createAtomic(x), t});
}
}



// true (non-formula) functional term parsing

/**
 * Parse a (non-formula) functional term for the current logic.
 */
Expression term() :
{Expression a;}
{
    a  = PrimaryTerm()
{return a;}
}

Expression PrimaryTerm() :
{Expression a;}
{
    (   LOOKAHEAD(2)
     	a = CompoundTerm()
     |  a = AtomicTerm()
     |	"(" a = expression() ")"
     )
	{return a;}
}

/**
 * Parse a compound function term for the current logic.
 */
Expression CompoundTerm() :
{Token tok; Expression p; Expression[] arg;}
{
    tok = <IDENTIFIER> arg = Arguments()
	{return apply(tok, arg, Object.class);}
|
    p = LambdaAbstraction() arg = Arguments()
        {
	    if (arg.length != 1)
	        throw new ParseException("only unary application of lambda abstractions is supported");
	    //@todo which exact optok token?
	    return composeWrapper(null, ClassicalLogic.APPLY, new Expression[] {p, arg[0]});
	}
}

/**
 * &lambda;-abstraction term.
 *@todo let our surroundings (not us) also support variables/constants bound to &lambda;-abstractions.
 * @note that (\x.2*x) can be parsed as expected because .2 is not a real number but only 0.2
 * @todo could we define the semantics by Logic.compose("lambda", new Expression[] {x, t}) such that someone can remember the (now fixed) interpretation as a function?
 *  However since substitution can be performed here, on a purely syntactical basis,
 *  it would be enough if the logic (or someone else) could somehow remember definitions for its interpretation.
 * @see orbital.logic.trs.Substitutions#lambda
 */
Expression LambdaAbstraction() :
{Token tok;Symbol x;Expression t;}
{
    "(" tok = <LAMBDA> x = Variable() "." {declare(x);} t = term() ")"
{
    undeclare(x);
    return composeWrapper(tok, ClassicalLogic.LAMBDA, new Expression[] {syntax.createAtomic(x), t});
}
}

/**
 * Parse an atomic term (function application, number or string) for the current logic.
 */
Expression AtomicTerm() :
{Symbol s;}
{
    (
     s = LiteralValue()
     |	s = ConstantOrVariable()
     )
	{return (Expression) syntax.createAtomic(s);}
}

// atomic values

/* LITERALS */

TOKEN :
{
    <INTEGER_LITERAL: <DECIMAL_LITERAL> >
|
    <#DECIMAL_LITERAL: (<DIGIT>)+ >
|
    <FLOATING_POINT_LITERAL:
          <DECIMAL_LITERAL> "." (<DECIMAL_LITERAL>)? (<EXPONENT>)?
	| <DECIMAL_LITERAL> (<EXPONENT>)?
    >
|
    <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
    <STRING_LITERAL:
	"\""
			   (   (~["\"","\\","\n","\r"])
			       | ("\\"
				  ( ["n","t","b","r","f","\\","'","\""]
				    | ["0"-"7"] ( ["0"-"7"] )?
				    | ["0"-"3"] ["0"-"7"] ["0"-"7"]
				    )
				  )
			       )*
			   "\""
    >
|   <#DIGIT : ["0"-"9"]>
}


/**
 * atomic term literal value (in the sense of constant primitive type), f.ex. number or string value.
 */
Symbol LiteralValue() :
{Token tok;Symbol s;}
{
    s = NumberLiteralValue()      	{return s;}
|   tok = <STRING_LITERAL> {
	if (tok.image.length() == 3) {
	    if (!((tok.image.charAt(0) == '\'' && tok.image.charAt(2) == '\'')
		  || (tok.image.charAt(0) == '"' && tok.image.charAt(2) == '"')))
	    throw new AssertionError("single character");
	    return new SymbolBase("\"" + tok.image.charAt(1) + "\"", STRING_LITERAL_TYPE);
	}
	return new SymbolBase(tok.image, STRING_LITERAL_TYPE);
    }
}

/**
 * purely numeric atomic term literal value (in the sense of constant primitive type).
 */
Symbol NumberLiteralValue() :
{Token tok;}
{
    tok = <INTEGER_LITERAL>      	{return new SymbolBase(tok.image, INTEGER_LITERAL_TYPE);}
|   tok = <FLOATING_POINT_LITERAL>      {return new SymbolBase(tok.image, FLOAT_LITERAL_TYPE);}
}

/**
 * Parses a constant or a variable atomic variable term,
 * depending upon known symbols in context.
 * @see #Variable()
 */
Symbol ConstantOrVariable() :
{String signifier;Token tok;String s = "";}
{
    tok = <IDENTIFIER> {signifier = tok.image;}
    /*      (
	    ( "." tok = <IDENTIFIER>  {signifier += "." + tok.image;} )
	    )*
    */
    {return symbolFor(signifier);}
}


/**
 * an atomic variable term.
 * @see #ConstantOrVariable()
 */
Symbol Variable() :
{String signifier;Token tok;String s = "";}
{
    tok = <IDENTIFIER> {signifier = tok.image;}
    /*      (
	    ( "." tok = <IDENTIFIER>  {signifier += "." + tok.image;} )
	    )*
    */
    {return new SymbolBase(signifier, SymbolBase.UNIVERSAL_ATOM, null, true);}
}

// Parsing Helpers

Expression[] Arguments() :
{Expression[] s = null;}
{
    "(" [ s = Argument_list() ] ")"
	{return s;}
}

Expression[] Argument_list() :
{List r = new LinkedList();Expression x;}
{
    x = term() {r.add(x);} ( "," x = term() {r.add(x);} )*
	{return (Expression[]) r.toArray(new Expression[0]);}
}
