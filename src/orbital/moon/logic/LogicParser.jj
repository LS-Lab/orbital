/**
 * @(#)LogicParser.jj 1.0 2001/01/16 Andre Platzer
 *
 * Copyright (c) 1999-2002 Andre Platzer. All Rights Reserved.
 *
 * This software is the confidential and proprietary information
 * of Andre Platzer. ("Confidential Information"). You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into.
 */

options {
    LOOKAHEAD = 1;
    STATIC = false;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(LogicParser)
package orbital.moon.logic;

import orbital.logic.imp.*;
import orbital.logic.functor.Notation.NotationSpecification;

import orbital.logic.functor.Function;
import orbital.logic.functor.Functions;

import orbital.logic.trs.Substitution;
import orbital.logic.trs.Substitutions;

import java.util.List;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.Iterator;
import orbital.math.MathUtilities;

import java.io.*;

import java.util.logging.Logger;
import java.util.logging.Level;

/**
 * It parses a concrete syntax (usually respecting the {@link Symbol#getNotation() notation of symbols}).
 * This class implements a parser for logic and mathematical formulas that can be used
 * for every logic after being bound to it. This parser calls {@link ExpressionBuilder}
 * on every connection point (which specify the parser actions).
 * Most ExpressionBuilders will simply construct a tree of Expressions (usually Formulas)
 * whose implementation depends on the logic.
 * <p>
 * Although this distinction may sometimes sound artificial,
 * we will - for the moment - distinguish three types of syntactic expressions:
 * <ul>
 *   <li>(arithmetic and functional) terms</li>
 *   <li>(logical) formulas</li>
 *   <li>unspecific expressions combining both terms and formulas</li>
 * </ul>
 * </p>
 * <p>
 * This parser can be used by implementations of ExpressionSyntax. So there
 * is no need to interface with this parser directly. Instead, it
 * is sufficient to call the {@link ExpressionSyntax#createExpression(String)}
 * implementation of the specific logic - which could in turn invoke this parser.
 * </p>
 * @version 1.0, 2001/01/16
 * @author  Andr&eacute; Platzer
 * @see <a href="doc-files/LogicParser_grammar.html">Grammar</a>
 * @see ExpressionSyntax#createExpression(String)
 * @see #parseFormula()
 * @see #parseFormulas()
 * @todo should use precedence and associativity information from
 * orbital.logic.imp.Symbol instead of hard wiring parser.
 * @xxx "disambiguate" language and disallow acception of $p(x) as $p (x) and °p(x) as °p (x) and alike
 * @todo get rid of all this (sometimes) triple exception wrapping and unwrapping by wrapping the final orbital.logic.imp.ParseException inside an unchecked exception once, and unwrap it once
 * @internal note that all this nested lookahead with a lot of backtracking kills performance.
 * @todo join symbiose of MathParser and LogicParser by letting expression() accept term(), directly as well? Instead of just providing two distinct start productions.
 * @todo get rid of all this exception wrapping and unwrapping by wrapping the final orbital.logic.imp.ParseException inside an unchecked exception once, and unwrap it once again? Necessary? There's not that much wrapping.
 */
public class LogicParser {
    private static final Logger logger = Logger.getLogger(LogicParser.class.getName());

    /**
     * Delegate to the current syntax implementation that is used for building expressions.
     */
    protected ExpressionSyntax syntax;

    // caches important types
    private transient Type TRUTH;
    private transient Type INDIVIDUAL;
    private transient Type UNIVERSAL;
    private transient Type INTEGER_LITERAL_TYPE;
    private transient Type FLOAT_LITERAL_TYPE;
    private transient Type STRING_LITERAL_TYPE;
	
    /**
     * The root scope, containing only the core signature.
     * @internal never use this scope directly, but always nest it inside another scope.
     * This ensures that root.symbolMap won't be modified.
     */
    protected transient Scope root;

    /**
     * The current scope.
     */
    protected Scope scope;

    /**
     * Set the current syntax for parsing.
     * @param syntax the expression syntax to use for parsing expressions (formulas).
     */
    public void setSyntax(ExpressionSyntax syntax) {
	this.syntax = syntax;
	Signature coreSignature = syntax.coreSignature();
	this.root = new RootScope(coreSignature);
	this.TRUTH = queryType(syntax, "truth");
	this.INDIVIDUAL = queryType(syntax, "individual");
	//@todo should we ask the syntax?
	this.UNIVERSAL = queryType(syntax, "univ");
	this.FLOAT_LITERAL_TYPE = queryType(syntax, "real");
	this.INTEGER_LITERAL_TYPE = queryType(syntax, "integer");
	this.STRING_LITERAL_TYPE = queryType(syntax, "string");
    }
    /**
     * Query the type (interpretation) of the type with the specified signifier from syntax.
     * @return null if no such type.
     */
    private static Type queryType(ExpressionSyntax syntax, String signifier) {
	Symbol symbol = syntax.coreSignature().get(signifier, new Expression[0]);
	if (symbol == null)
	    return null;
	return
	    (Type) (
		    syntax instanceof Logic
		    ? ((Logic)syntax).coreInterpretation().get(symbol)
		    : syntax instanceof MathExpressionSyntax /*@xxx prevent this special case*/
		    ? ((MathExpressionSyntax)syntax).coreInterpretation().get(symbol)
		    : null
		    );
    }

    /**
     * Converts an expression to the type it represents.
     * <table>
     * <tr>
     * <td>Expression<sub class="type">*</sub>&rarr;Type</td>
     * </tr>
     * <tr>
     * <td>f &#8614; (Type) I<sub>0</sub>(f)</td>
     * </tr>
     * </table>
     */
    protected Type asType(Expression f) {
	//@xxx
	if (false && f.getType() != Types.TYPE)
	    throw new IllegalArgumentException("would not expect type " + f + " for type expressions @xxx except for other kinds like *->*");
	return (Type) ((Formula) f).apply(InterpretationBase.EMPTY(syntax.coreSignature()));
    }

    /**
     * unary junctors.
     */
    protected Expression combine(Token optok, Expression a) throws ParseException {
    	String op = optok.image;
    	if (op.length() == 1)
	    switch (op.charAt(0)) {
	    case '!': /*fall-through*/
	    case '¬': op = "~"; break;
	    default: /*ignore*/
	    }
	return composeWrapper(optok, op, new Expression[] {a});
    }

    /**
     * binary junctors and relations.
     */
    protected Expression combine(Token optok, Expression a, Expression b) throws ParseException {
    	String op = optok.image;
    	// normalize alternative notation
    	switch (op.length()) {
	case 1:
	    switch (op.charAt(0)) {
	    case '\u2227': op = "&"; break;
	    case '\u2228': op = "|"; break;
	    case '\u2260': op = "!="; break;
	    case '\u2264': op = "=<"; break;
	    case '\u2265': op = ">="; break;
	    case '\u2194':
	    case '\u21d4': op = "<->"; break;
	    case '\u2283':
	    case '\u2192':
	    case '\u21d2': op = "->"; break;
	    default: /*ignore*/
	    }
	    break;

	case 2:
	    if ("&&".equals(op))
		op = "&";
	    else if ("||".equals(op))
		op = "|";
	    else if ("=>".equals(op))
		op = "->";
	    else if ("\u2228\u0307".equals(op))
		// note that this combining diacritical remark de facto has length 2
		op = "^";
	    break;

	case 3:
	    if ("<=>".equals(op))
		op = "<->";
	    else if ("xor".equals(op))
		op = "^";
	    break;

	default: /*ignore*/
        }
	return composeWrapper(optok, op, new Expression[] {a, b});
    }

    /**
     * quantifiers.
     */
    protected Expression combine(Token optok, Symbol x, Expression a) throws ParseException {
    	String op = optok.image;
    	if (op == null || x == null || a == null)
	    throw new NullPointerException("illegal arguments "+ optok + "," + x + "," + a);
    	// normalize alternative notation
    	if (op.length() == 1)
	    switch (op.charAt(0)) {
	    case '\u2200': op = "°"; break;
	    case '\u2203': op = "?"; break;
	    case '$': op = "free"; break;
	    default: /*ignore*/
	    }
    	if ("all".equals(op))
	    op = "°";
    	else if ("some".equals(op))
	    op = "?";

	if (!x.isVariable())
	    throw new AssertionError("parser would only combine quantifiers with variable symbols " + op + " " + x);
	if (!scope.contains(x))
	    throw new AssertionError("only symbols in the symbol map of current scope are quantified over");
	if ("free".equals(op))
	    throw new AssertionError("quantifier with pure syntactic function and no semantic aspect at all have already been filtered");
	return composeWrapper(optok, op, new Expression[] {
	    composeWrapper(optok, ClassicalLogic.LAMBDA, new Expression[] {syntax.createAtomic(x), a})
	});
    }

    // support
    
    /**
     * n-ary predicates or functions.
     * @param reqResult specifies the required result type, as derived from the context.
     *  Object.class for functions, and Boolean.class for predicates.
     * @see ExpressionBuilder#compose(Expression,Expression[])
     */
    protected Expression apply(Token optok, Expression[] a, Type reqResult) throws ParseException {
    	String op = optok.image;
	Symbol s = scope.getSymbol(op, Types.map(Types.typeOf(a), reqResult), true);
	return composeWrapper(optok, s, a);
    }

    /**
     * Wraps calls to {@link ExpressionBuilder#compose(Expression,Expression[])} in an exception handling block.
     * @param optok the token that initiated this operation (used in case of ParseExceptions to define the position).
     */
    private Expression composeWrapper(Token optok, Expression op, Expression[] arg) throws ParseException {
	if (op == null)
	    throw newParseException("illegal compositor: " + op, optok);
	try {
	    return syntax.compose(op, arg);
    	}
    	catch (orbital.logic.imp.ParseException ex) {throw newParseException(ex.getMessage(), optok, ex);}
    }
    /**
     * Wraps calls to {@link ExpressionBuilder#compose(Expression,Expression[])} in an exception handling block.
     * @param optok the token that initiated this operation (used in case of ParseExceptions to define the position).
     * @see <a href="{@docRoot}/Patterns/Design/Convenience.html">Convenience method</a>
     */
    private Expression composeWrapper(Token optok, Symbol op, Expression[] arg) throws ParseException {
	if (op == null)
	    throw newParseException("illegal compositor: " + op + " (used for " + optok + ")", optok);
	return composeWrapper(optok, syntax.createAtomic(op), arg);
    }
    /**
     * Wraps calls to {@link ExpressionBuilder#compose(Expression,Expression[])} in an exception handling block.
     * @param optok the token that initiated this operation (used in case of ParseExceptions to define the position).
     * @see <a href="{@docRoot}/Patterns/Design/Convenience.html">Convenience method</a>
     */
    private Expression composeWrapper(Token optok, String op, Expression[] arg) throws ParseException {
	Symbol s = scope.getSymbol(op, Types.map(Types.typeOf(arg), UNIVERSAL), false);
	if (s == null) {
	    //@todo remove since this does not occur because we don't use tryGetScope any more.
	    //@xxx an error is to come up, so already print some information about it
	    System.err.println(">> in signature ");
	    for (Iterator i = syntax.coreSignature().iterator(); i.hasNext(); ) {
		Symbol sym = (Symbol)i.next();
		System.err.println(sym + " of type " + sym.getType());
	    }
	    System.err.println(">> " + op + " applied to " + MathUtilities.format(arg) + " of type " + Types.typeOf(arg) + " not found");
	}
	return composeWrapper(optok, s, arg);
    }

    /**
     * Symbol declaration handling
     * @author Andr&eacute; Platzer
     * @verions 1.1, 2002-11-01
     */
    private static class Scope {
	/**
	 * the outer parental scope around this scope.
	 */
	private Scope outer;
	/**
	 * The accumulated signature already occured in the current scope.
	 */
	private Signature symbolMap;

	/**
	 * Create a new empty scope.
	 */
	public Scope() {
	    this((Scope)null);
	}
	/**
	 * Create a new scope with predefined symbols.
	 */
	protected Scope(Signature predefinedSymbols) {
	    this();
	    this.symbolMap = predefinedSymbols;
	}
	/**
	 * Create a new scope within an outer scope.
	 */
	public Scope(Scope outer) {
	    this.outer = outer;
	    this.symbolMap = new SignatureBase();
	}

	/**
	 * Leave this scope re-entering the parental outer scope.
	 * @return the outer scope re-entered.
	 */
	public Scope leave() {
	    return outer;
	}

	/**
	 * declare a new symbol.
	 */
	public void declare(Symbol x) {
	    if (x == null)
		throw new NullPointerException("illegal symbol " + x);
	    else if (!x.isVariable())
		throw new java.lang.AssertionError("parser would only combine quantifiers with variable symbols " + x);
	    symbolMap.add(x);
	}

	/**
	 * declare a new symbol.
	 */
	public boolean contains(Symbol x) {
	    return symbolMap.contains(x) || outer.contains(x);
	}
	
	/**
	 * Get a symbol of the specified signifier and expected type.
	 * Will lookup current scope and outer scope.
	 * @param maxType the maximum type expected as derived from the context.
	 * @param variable whether the symbol is expected to be a variable.
	 * @param autoDeclare whether to declare a new symbol if it is unknown,
	 *  instead of returning <code>null</code>.
	 * @return the symbol if exists.
	 * @throws IllegalArgumentException if no such symbol exists.
	 */
	public Symbol getSymbol(String signifier, Type maxType, boolean variable, boolean autoDeclare) {
	    Symbol s = tryGetSymbol(signifier, maxType, variable, autoDeclare);
	    if (s == null)
		throw new IllegalArgumentException("unknown symbol: " + signifier);
	    else
		return s;
	}
	public Symbol getSymbol(String signifier, Type maxType, boolean autoDeclare) {
	    return getSymbol(signifier, maxType, false, autoDeclare);
	}

	/**
	 * Get a symbol of the specified signifier and expected type.
	 * Will lookup current scope and outer scope.
	 * @param maxType the maximum type expected as derived from the context.
	 * @param variable whether the symbol is expected to be a variable.
	 * @param autoDeclare whether to declare a new symbol if it is unknown,
	 *  instead of returning <code>null</code>.
	 * @return the symbol or <code>null</code>.
	 */
	private Symbol tryGetSymbol(String signifier, Type maxType, boolean variable, boolean autoDeclare) {
	    Symbol s = tryGetSymbol(signifier, maxType);
	    if (s != null)
		return s;
	    if (outer != null) {
		// declared in the parent's (outer) scope, but don't autoDeclare there
		s = outer.tryGetSymbol(signifier, maxType, variable, false);
		if (s != null)
		    return s;
	    }

	    //@internal first look if there is a symbol of parametric type matching ours
	    //@fixme note that this does not only find those of parametric types but may hit the first with non-parametric type
	    s = tryGetSymbol(signifier, Types.UNIVERSAL);
	    if (s != null && s.getType() instanceof ClassicalLogic.PiAbstractionType)
		return s;

	    // treated "the default way"
	    return autoDeclare
		? variable
		  ? new SymbolBase(signifier, maxType, null, variable)
		  : getDefaultSymbol(signifier, maxType)
		: null;
	}
	private Symbol tryGetSymbol(String signifier, Type maxType) {
	    Symbol s = symbolMap.get(signifier, maxType);
	    if (s != null) {
		// we already know it due to a quantifier within whose scope we are
		//@todo use Types.map(Types.product(arityOf(maxType.domain()), UNIVERSAL), UNIVERSAL) instead to catch even more similarities?
		Symbol s2 = symbolMap.get(signifier, Types.map(maxType.domain(), Types.UNIVERSAL));
		if (!s.equals(s2))
		    throw new IllegalArgumentException("nonunique names\n\t" + signifier + ":" + maxType + " ressembles\n\t" + s + " of type " + s.getType() +"\n\tand " + s2 + " of type " + s2.getType() + " too much.");
		else
		    return s;
	    }
	    return s;
	}

	public String toString() {
	    return "{<" + outer + " scope " + symbolMap + ">}";
	}
    }

    //@todo remove this garbage, because we should always let the user decide what's constant and what's variable, (or at least let him choose the capital/lower convention)
    // either the user can call createExpression(String expr, Signature allowed),
    // or he should explicitly mention any free variables, and all other symbols are either explicitly quantified, or treated as constant
    //@todo rely on FreeDeclarationExpression
    /**
     * lets _ modify whether it is a variable, not touching its type.
     * @xxx can we somehow get rid of this?
     */
    static Symbol getDefaultSymbol(String signifier, Type expectedType) {
	//@xxx currently we (in addition to $) distinguish between variables and constants according to their first character
	return signifier.charAt(0) == '_'
	    ? new SymbolBase(signifier, expectedType, null, true)
	    : new SymbolBase(signifier, expectedType, null, false);
    }
    /**
     * Symbol handling for the root scope.
     * @author Andr&eacute; Platzer
     * @verions 1.1, 2002-11-05
     */
    private static class RootScope extends Scope {
	/**
	 * Create a new scope with predefined symbols.
	 */
	protected RootScope(Signature predefinedSymbols) {
	    super(predefinedSymbols);
	}
	public void declare(Symbol x) {
	    throw new InternalError("modifying the root scope is not allowed");
	}
    }

    /**
     * Reads a term-rewrite system from a stream.
     * The concrete syntax of the TRS specification source is
     * <pre>
     * &lt;matchingSide&gt; |- &lt;replacementSide&gt;    # &lt;comment&gt; &lt;EOL&gt;
     * ...
     * </pre>
     * where <code>&lt;matchingSide&gt;</code> and <code>&lt;replacementSide&gt;</code>
     * are well-formed expressions of the {@link ExpressionSyntax#createExpression(String) (concrete) syntax}
     * defined by <code>syntax</code>.
     * @param reader the source for the TRS specification.
     * @param syntax the syntax for parsing expressions.
     * @param expressionTransformation the function {@link Expression}&rarr;T used for transforming
     *  the expressions parsed (<code>&lt;matchingSide&gt;</code> and <code>&lt;replacementSide&gt;</code>)
     *  prior to constructing the substitution.
     * @throws IOException when an error occurs while reading from the reader.
     * @throws orbital.logic.imp.ParseException when a syntax error occurs in the source.
     */
    public static final Substitution readTRS(final Reader reader, final ExpressionSyntax syntax, final Function expressionTransformation)
	throws IOException, orbital.logic.imp.ParseException {
	final String ruleDelim = "|-";
	final LineNumberReader rd = new LineNumberReader(reader);
	final List rules = new LinkedList();
	String l;
	while ((l=rd.readLine()) != null) {
	    final String original = l;
	    if (l.indexOf('#') >= 0)
		// strip comment
		l = l.substring(0, l.indexOf('#'));
	    l = l.trim();
	    if (l.length() == 0)
		continue;
	    int rule = l.indexOf(ruleDelim);
	    if (rule < 0)
		throw new orbital.logic.imp.ParseException("neither comment nor whitespace nor rule", rd.getLineNumber(), 1);
	    rules.add(
		      Substitutions.createSingleSidedMatcher(
							     expressionTransformation.apply(syntax.createExpression(l.substring(0, rule))),
							     expressionTransformation.apply(syntax.createExpression(l.substring(rule + ruleDelim.length())))
							     )
		      );
	}
	return Substitutions.getInstance(new ArrayList(rules));
    }
    /**
     * Reads a term-rewrite system from a stream.
     * Using the identity transformation.
     * @see #readTRS(Reader,ExpressionSyntax,Function)
     */
    public static final Substitution readTRS(final Reader reader, final ExpressionSyntax syntax)
	throws IOException, orbital.logic.imp.ParseException {
	return readTRS(reader, syntax, Functions.id);
    }

    /**
     * Create a good parse exception with the specified message for the given token parsed.
     */
    static ParseException newParseException(String message, Token tok, Exception cause) {
	return (ParseException) newParseException(message, tok).initCause(cause);
    }
    static ParseException newParseException(String message, Token tok) {
	final ParseException x = new ParseException(message);
	x.currentToken = tok;
    	return x;
    }
}
PARSER_END(LogicParser)

SKIP :
{
    " "
|   "\r"
|   "\t"
|   < EOL: "\n" >
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

// operator tokens
TOKEN :
{
  <DECLARE_FREE: "$" | "free">
| <EXISTS: "\u2203" | "?" | "some">
| <FORALL: "\u2200" | "°" | "all">

| <EQUIV: "\u2194" | "\u21d4" | "<->" | "<=>">
| <IMPLY: "\u2192" | "\u21d2" | "\u2283" | "->" | "=>">
| <OR: "\u2228" | "|" | "||">
	//@todo use a better symbol than ^ for xor. Otherwise 4^5 could mean 4 to the power of 5, or 4 xor 5.
| <XOR: "\u2228\u0307" | "xor" | "^">
| <AND: "\u2227" | "&" | "&&">

| <NOT: "¬" | "~" | "!">

| <EQUAL: "=" | "==">
| <UNEQUAL: "\u2260" | "!=">
| <LESS: "<">
| <GREATER: ">">
| <LESS_EQUAL: "\u2264" | "=<">
| <GREATER_EQUAL: "\u2265" | ">=">

| <LAMBDA: "\u03bb" | "\\">
| <PI: "\u03a0" | "\\\\">
}

/**
 * Start production parsing a set of logic formulas with the current syntax.
 * @return the set of formulas parsed,
 *  or an array of length 0 if only the empty set of formulas was found.
 * @see #parseFormula()
 * @todo should we really introduce this method into orbital.logic.imp.Logic/ExpressionSyntax? What would be the delimiters of the individual formulas of a set?
 * @internal we require <EOF> to be sure we parsed all, and no syntactic garbage lurks around at the end of the input
 */
Expression[] parseFormulas() :
{
    scope = new Scope(root);
    List r = new LinkedList();
    Expression expr;
}
{
    expr = expression() {r.add(expr);} ( "," expr = expression() {r.add(expr);} )* <EOF>
	{return (Expression[]) r.toArray(new Expression[0]);}
    | <EOF>
	{ return new Expression[0];}
}


/**
 * Start production parsing a logic formula with the current syntax.
 * @see #parseFormulas()
 * @internal we require <EOF> to be sure we parsed all, and no syntactic garbage lurks around at the end of the input
 */
Expression parseFormula() :
{
    scope = new Scope(root);
    Expression expr;
}
{
    expr = expression() <EOF>
	{ return expr; }
    | <EOF>
	{ return null;/* must be converted later into a denotation of the empty formula */ }
}

/**
 * Start production parsing an arithmetic formula expression.
 * @internal we require <EOF> to be sure we parsed all, and no syntactic garbage lurks around at the end of the input
 */
Expression parseTerm() :
{
    scope = new Scope(root);
    Expression expr;
}
{
    expr = term() <EOF>
	{ return expr; }
  | <EOF>
	{ return null; }
}

// formula parsing methods

/**
 * Central expression parsing production.
 */
Expression expression() :
{Expression f;}
{
    f = FreeDeclarationExpression()
	{return f;}
}

//@todo introduce &jota; x.f operator (by Bertrand Russell)
//@todo introduce Hilbert's &epsilon; x.f operator. If f is true for some value of x, then &epsilon; x.f denotes some such value, otherwise it has an arbitrary value of the same type as x. (embodies the strong Axiom of Choice). @see "Paulson, L.C. The Foundation of a Generic Theorem Prover."

/**
 * free scope "quantifier"
 * A "quantifier" with a purely syntactic function of declaring a variable.
 * @internal introduced an explicit "quantifier" for free variables, resolving all conflicts with variable/constant detection
 * then we can keep track of the accumulated signature during parse and treat everything constant that's not already declared in the signature (and all three binding quantifier will extend the current signature)
 */
Expression FreeDeclarationExpression() :
{
    Token tok = null;Symbol x = null;Expression a;
    scope = new Scope(scope);
}
{
    (tok = <DECLARE_FREE> x = VariableDeclaration()
	{
	    scope.declare(x);
	    logger.log(Level.FINER, "declared {0}:{1}", new Object[] {x, x.getType()});
	}
     )*

    a = QuantifiedExpression()
{
    scope = scope.leave();
    return a;
}
}

// quantifiers
  
//@todo reduce the binding domain of the quantifiers to the next expression, only, and require "all x (p&q)" instead. Rearrange precedence, such that "all" and "some" bind stronger than &,|,->,<=>
Expression QuantifiedExpression() :
{
    Token tok = null;List xs = new LinkedList();Symbol x = null;Expression a = null;
    scope = new Scope(scope);
}
{
    ((tok = <FORALL> | tok = <EXISTS>) x = VariableDeclaration() {scope.declare(x);xs.add(x);})*
    a = EquivalenceExpression()
	{
	    for (Iterator i = xs.iterator(); i.hasNext(); ) {
		Symbol y = (Symbol) i.next();
		a = combine(tok, y, a);
	    }
	    scope = scope.leave();
	    return a;
	}
}

// junctors

Expression EquivalenceExpression() :
{Token tok;Expression a,b;}
{
    a = ImplicationExpression() ( tok = <EQUIV> b = ImplicationExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

//@todo introduce reverse implication as well
Expression ImplicationExpression() :
{Token tok;Expression a,b;}
{
    a = InclusiveOrExpression() ( tok = <IMPLY> b = InclusiveOrExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

Expression InclusiveOrExpression() :
{Token tok;Expression a,b;}
{
    a = ExclusiveOrExpression() ( tok = <OR> b = ExclusiveOrExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

Expression ExclusiveOrExpression() :
{Token tok;Expression a,b;}
{
    a = AndExpression() ( tok = <XOR> b = AndExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

Expression AndExpression() :
{Token tok;Expression a,b;}
{
    a = UnaryExpression() ( tok = <AND> b = UnaryExpression() {a = combine(tok, a,b);} )*
	{return a;}
}

// unary operators

//@todo how to parse ~all x p(x) where all x p(x) is not a UnaryExpression?
Expression UnaryExpression() :
{Token tok;Expression f;}
{
    tok = <NOT> f = UnaryExpression() {return combine(tok, f);}
    | f = PrimaryExpression()
	{return f;}
}

/**
 * Final expression parsing production (in addition to {@link #Atom()}).
 * primary formulas that have truth values
 */
Expression PrimaryExpression() :
{Expression a;}
{
    (LOOKAHEAD(Atom())  //@xxx sure? Also note that this is a dramatic performance bottleneck
     a = Atom()
     |	"(" a = expression() ")"
     )
	{return a;}
}

/* IDENTIFIERS */

//@note must be below the keyword tokens like "and", "xor" due to (first) longest-possible match
TOKEN :
{
    <IDENTIFIER : <LETTER> (<LETTER>|<DIGIT_OR_ALIKE>)* >
|   <#LETTER : ["A"-"Z", "a"-"z", "","","_"]>
|   <#DIGIT_OR_ALIKE : ["0"-"9"]>
}


/**
 * A formula that is a logical atom.
 * @todo better distinguish between variables and constants (with the possibility for both to appear in	compound expressions for PL2)
 */
Expression Atom() :
{Expression a;String r;Token tok;String s = "";Symbol sym;}
{
    LOOKAHEAD(2)
	a = CompoundFormula()
	{return a;}
    |
	tok = <IDENTIFIER>
	{return (Expression) syntax.createAtomic(scope.getSymbol(tok.image, TRUTH, true));}
    |
	sym = NumberLiteralValue()
	{return (Expression) syntax.createAtomic(sym);}
}

/**
 * Parse a compound predicate formula for the current logic.
 */
Expression CompoundFormula() :
{Token tok; Expression p; Expression[] arg;}
{
    LOOKAHEAD(2)
    p = EqualityExpression()
        {return p;}
|
    tok = <IDENTIFIER> arg = Arguments()
	{return apply(tok, arg, TRUTH);}
|
    p = LambdaAbstractionPredicate() arg = Arguments()
        {
	    if (arg.length != 1)
 	        throw newParseException("only unary application of lambda abstractions is supported. Use currying instead.", null);
	    //@todo which exact optok token?
	    return composeWrapper(null, p, arg);
	}
}

// relational operators (special predicates on terms)

// Expression EqualityExpression() :
// {Token tok;Expression a,b;}
// {
//     a = RelationalExpression() ( (tok = <EQUAL> | tok = <UNEQUAL>) b = RelationalExpression() {a = combine(tok, a, b);} )*
// 	{return a;}
// }

// Expression RelationalExpression() :
// {Token tok;Expression a,b;}
// {
//     a = term() ( ( tok = <LESS> | tok = <GREATER> | tok = <LESS_EQUAL> | tok = <GREATER_EQUAL> ) b = term() {a = combine(tok, a, b);} )*
// 	{return a;}
// }

//@internal unified EqualityExpression() and RelationalExpression() such that we can replace * by + thereby making it impossible to parse a simple <IDENTIFIER> as such an EqualityExpression()
//  we ensure that we only take this path if EqualityExpression() does not reduce to <IDENTIFIER>
Expression EqualityExpression() :
{Token tok;Expression a,b;}
{
    //@xxx these extra brackets have been introduced temporarily in order to enable parsing (\x. 7>=x)(8) which somehow does not work otherwise (due to a LOOKAHEAD problem)
    "("
	a = term() ( (tok = <EQUAL> | tok = <UNEQUAL> | tok = <LESS> | tok = <GREATER> | tok = <LESS_EQUAL> | tok = <GREATER_EQUAL> ) b = term() {a = combine(tok, a, b);} )+
    ")"
	{return a;}
}

/**
 * &lambda;-abstraction predicate.
 * @see orbital.logic.trs.Substitutions#lambda
 */
Expression LambdaAbstractionPredicate() :
{
    Token tok; Symbol x;Expression t;
    scope = new Scope(scope);
}
{
    "(" tok = <LAMBDA> x = VariableDeclaration() "." {scope.declare(x);} t = expression() ")"
{
    scope = scope.leave();
    return composeWrapper(tok, ClassicalLogic.LAMBDA, new Expression[] {syntax.createAtomic(x), t});
}
}



// true (non-formula) functional term parsing

/**
 * Central term parsing production.
 * Parse a (non-formula) functional term for the current logic.
 */
Expression term() :
{Expression a;}
{
    a  = SumTerm()
{return a;}
}

// junctors

Expression SumTerm() :
{Token tok;Expression a, b;}
{
    a = ProductTerm() ( (tok = "+" | tok = "-") b = ProductTerm() {a = combine(tok, a, b);} )*
{return a;}
}

Expression ProductTerm() :
{Token tok;Expression a, b;}
{
    a = PowerTerm() ( (tok = "*" | tok = "/") b = PowerTerm() {a = combine(tok, a, b);} )*
{return a;}
}

Expression PowerTerm() :
{Token tok;Expression a, b;}
{
    // right associative xfy
    //@xxx XOR != "^" != "**"
    a = UnaryTerm() (tok = <XOR> b = PowerTerm() {a = combine(tok, a, b);} )?
{return a;}
}

// unary operators

Expression UnaryTerm() :
{Token tok;Expression v;}
{
    ( tok = "+" | tok = "-" ) v = UnaryTerm() {return combine(tok, v);}
|   v = PrimaryTerm() {return v;}
}

/**
 * Final term parsing production (in addition to {@link #AtomicTerm()}).
 */
Expression PrimaryTerm() :
{Expression a;}
{
    (   LOOKAHEAD(2)
     	a = CompoundTerm()
     |  a = AtomicTerm()
     |	"(" a = term() ")"
     )
	{return a;}
}

/**
 * Parse a compound function term for the current logic.
 */
Expression CompoundTerm() :
{Token tok; Expression f; Expression[] arg;}
{
    tok = <IDENTIFIER> arg = Arguments()
	{return apply(tok, arg, INDIVIDUAL);}
|
	//@todo also allow non-applied LambdaAbstractions like in f((\x.x+2))
    f = LambdaAbstraction() arg = Arguments()
        {
	    if (arg.length != 1)
	        throw newParseException("only unary application of lambda abstractions is supported", null);
	    //@todo which exact optok token?
	    return composeWrapper(null, f, arg);
	}
}

/**
 * &lambda;-abstraction term.
 * @todo let our surroundings (not us) also support variables/constants bound to &lambda;-abstractions.
 * @note that (\x.2*x) can be parsed as expected because .2 is not a real number but only 0.2
 * @todo could we define the semantics by Logic.compose("lambda", new Expression[] {x, t}) such that someone can remember the (now fixed) interpretation as a function?
 *  However since substitution can be performed here, on a purely syntactical basis,
 *  it would be enough if the logic (or someone else) could somehow remember definitions for its interpretation.
 * @see orbital.logic.trs.Substitutions#lambda
 */
Expression LambdaAbstraction() :
{
    Token tok; Symbol x; Expression t;
    scope = new Scope(scope);
}
{
    "(" tok = <LAMBDA> x = VariableDeclaration() "." {scope.declare(x);} t = term() ")"
{
    scope = scope.leave();
    return composeWrapper(tok, ClassicalLogic.LAMBDA, new Expression[] {syntax.createAtomic(x), t});
}
}

/**
 * Parse an atomic term (function application, number or string) for the current logic.
 */
Expression AtomicTerm() :
{Symbol s;}
{
    (
        s = LiteralValue()
     |	s = ConstantOrVariable()
    )
	{return (Expression) syntax.createAtomic(s);}
}

// atomic values

/* LITERALS */

TOKEN :
{
    <INTEGER_LITERAL: <DECIMAL_LITERAL> >
|
    <#DECIMAL_LITERAL: (<DIGIT>)+ >
|
    <FLOATING_POINT_LITERAL:
          <DECIMAL_LITERAL> "." (<DECIMAL_LITERAL>)? (<EXPONENT>)?
	| <DECIMAL_LITERAL> (<EXPONENT>)?
    >
|
    <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
    <STRING_LITERAL:
	"\""
			   (   (~["\"","\\","\n","\r"])
			       | ("\\"
				  ( ["n","t","b","r","f","\\","'","\""]
				    | ["0"-"7"] ( ["0"-"7"] )?
				    | ["0"-"3"] ["0"-"7"] ["0"-"7"]
				    )
				  )
			       )*
			   "\""
    >
|   <#DIGIT : ["0"-"9"]>
}


/**
 * atomic term literal value (in the sense of constant primitive type), f.ex. number or string value.
 */
Symbol LiteralValue() :
{Token tok;Symbol s;}
{
    s = NumberLiteralValue()      	{return s;}
|   tok = <STRING_LITERAL> {
	if (tok.image.length() == 3) {
	    if (!((tok.image.charAt(0) == '\'' && tok.image.charAt(2) == '\'')
		  || (tok.image.charAt(0) == '"' && tok.image.charAt(2) == '"')))
	    throw new AssertionError("single character");
	    return new SymbolBase("\"" + tok.image.charAt(1) + "\"", STRING_LITERAL_TYPE);
	}
	return new SymbolBase(tok.image, STRING_LITERAL_TYPE);
    }
}

/**
 * purely numeric atomic term literal value (in the sense of constant primitive type).
 */
Symbol NumberLiteralValue() :
{Token tok;}
{
    tok = <INTEGER_LITERAL>      	{return new SymbolBase(tok.image, INTEGER_LITERAL_TYPE);}
|   tok = <FLOATING_POINT_LITERAL>      {return new SymbolBase(tok.image, FLOAT_LITERAL_TYPE);}
}

/**
 * Parses a constant or a variable atomic term,
 * depending upon known symbols in context.
 * @see #Variable()
 * @internal we reject boolean types, since this production only gets called from term(), not expression().?
 */
Symbol ConstantOrVariable() :
{String signifier;Token tok;String s = "";}
{
    tok = <IDENTIFIER> {signifier = tok.image;}
    /*      (
	    ( "." tok = <IDENTIFIER>  {signifier += "." + tok.image;} )
	    )*
    */
    {
	try {
	    // accept any type
	    //@xxx which exact type? univ\truth?
	    return scope.getSymbol(signifier, UNIVERSAL, false);
	} catch (IllegalArgumentException unknownSymbol) {
	    // only auto-declare as individual
	    return scope.getSymbol(signifier, INDIVIDUAL, true);
	}
    }
}


/**
 * an atomic variable term.
 * @see #ConstantOrVariable()
 */
Symbol Variable() :
{String signifier;Token tok;String s = "";}
{
    tok = <IDENTIFIER> {signifier = tok.image;}
    /*      (
	    ( "." tok = <IDENTIFIER>  {signifier += "." + tok.image;} )
	    )*
    */
    {return scope.getSymbol(signifier, INDIVIDUAL, true);}
}
/**
 * an atomic variable term with a type declaration.
 */
Symbol VariableDeclaration() :
{String signifier;Token tok;Type type = INDIVIDUAL;}
{
    tok = <IDENTIFIER> {signifier = tok.image;}
    (":" type = typeUse())?
    //@todo could use scope.getSymbol() but with variable:=true, but we are used for declarations anyway so it is unimportant.
    {return new SymbolBase(signifier, type, null, true);}
}

// type parsing

/**
 * A type use.
 */
Type typeUse() :
{Expression a;}
{
    a = type()
    {
	return asType(a);
    }
}

/**
 * Central type parsing production.
 * Parse a type expression for the current logic.
 */
Expression type() :
{Expression a;}
{
    a = MapType()
    {return a;}
}

Expression MapType() :
{Token tok;Expression a,b;}
{
    a = PrimaryType() ( tok = <IMPLY> b = PrimaryType() {a = combine(tok, a,b);} )*
	{return a;}
}

Expression PiAbstractionType() :
{
    Token tok, xtok; Symbol x; Expression t;
    scope = new Scope(scope);
}
{
    "(" tok = <PI> xtok = <IDENTIFIER> "."
	{scope.declare(x = scope.getSymbol(xtok.image, Types.TYPE, true, true));}
    t = type() ")"
{
    scope = scope.leave();
    return composeWrapper(tok, ClassicalLogic.PI, new Expression[] {syntax.createAtomic(x), t});
}
}

/**
 * A primary type.
 */
Expression PrimaryType() :
{Token tok;Expression a;}
{
    LOOKAHEAD(2)
    tok = <IDENTIFIER>
	{return syntax.createAtomic(scope.getSymbol(tok.image, Types.TYPE, true));}
    |   "[" a = CompoundType() "]"
	{return a;}
    | LOOKAHEAD(2)
	a = PiAbstractionType()
	{return a;}
    |   "(" a = type() ")"
	{return a;}
}

/**
 * A compound type.
 */
Expression CompoundType() :
{Token tok; Expression[] arg;}
{
    tok = <IDENTIFIER> arg = Types()
	{return apply(tok, arg, Types.TYPE);}
}

// Parsing Helpers

Expression[] Arguments() :
{Expression[] s = null;}
{
    "(" [ s = Argument_list() ] ")"
	{return s;}
}

Expression[] Argument_list() :
{List r = new LinkedList();Expression x;}
{
    x = term() {r.add(x);} ( "," x = term() {r.add(x);} )*
	{return (Expression[]) r.toArray(new Expression[0]);}
}

Expression[] Types() :
{Expression[] s = null;}
{
    "(" [ s = Type_list() ] ")"
	{return s;}
}

Expression[] Type_list() :
{List r = new LinkedList();Expression x;}
{
    x = type() {r.add(x);} ( "," x = type() {r.add(x);} )*
	{return (Expression[]) r.toArray(new Expression[0]);}
}
