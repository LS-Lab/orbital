import orbital.algorithm.template.*;
import orbital.logic.functor.Function;
import orbital.io.*;
import orbital.text.*;
import orbital.robotic.strategy.*;
import orbital.util.Pair;
import java.util.*;
import java.io.*;

/**
 * Huffman compression.
 * Creates the huffman code for a file.
 *
 * @version 0.9, 2000/08/07
 * @author  Andr&eacute; Platzer
 */
public class Huffman implements GreedyProblem {
    public static void main(String arg[]) throws Exception {
    	File file = new File(arg.length>0 ? arg[0] : "t.txt");
    	OccurrenceAnalyzer occurrences = new OccurrenceAnalyzer();
    	AnalyzingInputStream is = new AnalyzingInputStream(new FileInputStream(file), occurrences);
    	IOUtilities.copy(is, null);					// read all
    	Huffman h = new Huffman(occurrences.getOccurrences());
    	List code = new Greedy().solve(h);
    	System.out.println(code);
		//TODO: heapify reverted huffman_trie
    	Collections.reverse(h.huffman_trie);
		// use huffman code to perform compression
		/*OutputStream os;
		encode(new FileInputStream(file), os = new FileOutputStream(IOUtilities.changeExtension(file, ".cmp")), h.huffman_trie);
		os.close();*/
    }
    
    private double[] occurrences;
    public Huffman(double[] occurrences) {
    	this.occurrences = occurrences;
    }

    /**
     * Binary decision trie containing huffman codes of the byte b at the corresponding index b.
     * This trie is kept in <b>reverse</b> order during construction
     * and must be reverted and turned into a heap after a solution is found.
     */
    private List huffman_trie;

    /** buffers last new_choice object until next new_choice (for adding pairs of choices) */
    private Object last_new_choice = null;
    /** keeps the last new node added by nextPartialSolution */
    private Object new_node = null;
    private Node new_nodeNode = null;

    public List getInitialCandidates() {
    	huffman_trie = new ArrayList(2 * (Byte.MAX_VALUE - Byte.MIN_VALUE));
    	List c = new LinkedList();
    	for (int i = 0; i < occurrences.length; i++) {
    		if (occurrences[i] != 0)
    		    c.add(new Pair(new String("" + (char) i), new Double(occurrences[i])));
    	}
    	return c;
    }

	public Function getWeightingFor(List choices) {
		return weighting;
	}
	private Function weighting = new Function() {
		public Object apply(Object o) {
			return new Double(-((Number) ((Pair) o).B).doubleValue());
		}
	};

    /**
     * Extends the choices with a new_choice if that is feasible, otherwise nothing is changed.
     * @pre choices is a valid partial solution, new_choice has maximum local weight.
     * @post RES new solution value that includes new_choice if feasible.
     */ 
    public List nextPartialSolution(List choices, Object new_choice) {
    	// we use huffman_trie instead of choices
    	if (last_new_choice == null) {
    		// remember single choice and return
    		last_new_choice = new_choice;
    		return choices;
    	}
    	// we have two new choices so let's make a new node containing both children
    	Pair c1 = (Pair) last_new_choice;
    	Pair c2 = (Pair) new_choice;
    	huffman_trie.add(c1.A + "");
    	huffman_trie.add(c2.A + "");
    	String new_key = "" + c1.A + c2.A;
    	double weight_sum = ((Number) c1.B).doubleValue() + ((Number) c2.B).doubleValue();
    	new_node = new Pair(new_key, new Double(weight_sum));
    	new_nodeNode = new ListTree.TreeNode(new_node.A, new_node.B);
    	last_new_choice = null;
    	choices.add(new_node);
    	return choices;
    }

    public List nextCandidates(List candidates) {
    	if (new_node == null)
    		return candidates;
    	// add new node to the list of candidates
    	candidates.add(new_node);
    	// clear the reference to the new candidate that has alread been added
    	new_node = null;
    	return candidates;
    }

    public boolean isPartialSolution(List choices) {return true;}

    public boolean isSolution(List choices) {
    	huffman_trie.add(((Pair) last_new_choice).A);
    	System.out.println(huffman_trie);
    	return true;
    }
    
    private static void encode(InputStream is, OutputStream os, List heap) throws IOException {
    	System.out.println(heap);
    	while (is.available() > 0) {
    		int b = is.read();
    		BitSet c = code((char) b, heap);
    		// simplified byte-wise write (which is of course not for compression but for easy demonstration)
    		int val = 0;
    		for (int i = 0; i < c.length(); ) {
    			for (int k = 0; k < 8; k++)
    				val |= c.get(i++) ? 1 << k : 0;
    			os.write(val);
    		}
    	}
    }
    
    private static BitSet code(char b, List heap) {
    	BitSet c = new BitSet();
    	int index = 0;
    	int i = 0;
    	while (!heap.get(i).equals("" + b)) {
    		int ni;
    		if (((String) heap.get(ni = 2*i + 1)).indexOf(b) >= 0)
    			c.clear(index++);
    		else if (((String) heap.get(ni = 2*i + 2)).indexOf(b) >= 0)
    			c.set(index++);
    		else
    			throw new InternalError("unsupported character '" + b + "' for encoding");
    		i = ni;
    	}
    	return c;
    }
}